# 9.9 Zotero Note Editor 搜索性能分析

## 一、核心问题定位

### 官方源码流程
```
用户输入 → setSearchTerm() → dispatch(tr) → ProseMirror state更新 
→ updateView() → search() + DecorationSet.create() → dispatch(tr) 
→ 触发 decorations prop → ProseMirror 重渲染整个文档
```

**每次输入都触发2次 dispatch()，导致 ProseMirror 完整重建 DOM**

### Better Notes 插件流程
```
用户输入 → debounce 300ms → TreeWalker遍历DOM文本节点 
→ 正则匹配 → Range.getClientRects() → CSS overlay定位
→ 无 dispatch，无 ProseMirror 参与
```

---

## 二、关键差异对比

| 维度 | 官方实现 | Better Notes 插件 |
|------|----------|-------------------|
| **搜索数据源** | `doc.descendants()` 遍历 ProseMirror 文档 | `TreeWalker` 遍历 DOM 文本节点 |
| **高亮方式** | `DecorationSet.create()` 创建 Decoration | CSS absolute 定位 overlay |
| **触发渲染** | `dispatch(tr)` 触发完整重渲染 | 零 ProseMirror 交互 |
| **位置计算** | `coordsAtPos()` | `Range.getClientRects()` |

---

## 三、瓶颈分析

### 3.1 dispatch(tr) 问题
**不是搜索慢，是 dispatch 触发 ProseMirror 重渲染慢**

官方代码在 `setSearchTerm()` 中直接调用 `dispatch(state.tr)`，这会：
1. 触发所有 Plugin 的 `apply()` 
2. 触发 `view.update()` 重建 DOM
3. 触发 `decorations prop` 重新计算和应用 DecorationSet

### 3.2 DecorationSet.create() 问题
```javascript
// 官方代码 - 为每个结果创建 Decoration
let list = this.results.map((deco, index) => (
    Decoration.inline(deco.from, deco.to, { class: ... })
));
this.decorations = DecorationSet.create(tr.doc, list);
```

当有 1760 个结果时，创建 1760 个 Decoration 对象并重新渲染，这本身就是 O(n) 复杂度。

### 3.3 为什么我们的 CSS overlay 方案也慢？

**根本原因：`search(doc)` 函数本身使用 `doc.descendants()` 遍历 ProseMirror 文档**

```javascript
doc.descendants((node, pos) => {
    // 对每个节点调用回调
    // 500k 字符 = 数千个文本节点
});
```

这个遍历对于大文档来说**固有地慢**（~500-1000ms）。

---

## 四、为什么插件能解决但原生不行？

### 插件的优势
1. **不走 ProseMirror 搜索路径** - 直接搜 DOM
2. **独立 UI** - 不依赖官方搜索状态
3. **零 dispatch** - 完全绕开状态管理

### 原生的限制
1. **必须维护 ProseMirror 文档位置** - 因为需要支持 replace/replaceAll
2. **DecorationSet 是唯一官方高亮方式** - 绑定到 dispatch 流程
3. **search() 被设计为同步函数** - 没有分块或异步处理

---

## 五、可行解决方案

### 方案 A：完全绕开 ProseMirror（插件方式）
- ✅ 性能最优
- ❌ 丢失 replace 功能的精确位置映射
- ❌ 需要重写整个搜索系统

### 方案 B：异步/分块搜索
```javascript
async search(doc) {
    // 使用 requestIdleCallback 或 setTimeout 分块处理
    const chunks = splitDocIntoChunks(doc, 100);
    for (const chunk of chunks) {
        await processChunk(chunk);
        // 允许 UI 响应
    }
}
```
- ✅ 保持 ProseMirror 位置精度
- ⚠️ 结果逐步显示
- ⚠️ 需要处理搜索取消

### 方案 C：Web Worker 后台搜索
- ✅ 完全不阻塞 UI
- ❌ Worker 无法访问 DOM 和 ProseMirror 实例
- ❌ 需要序列化文档数据

### 方案 D：混合方案（推荐给 PR）
1. **搜索用 DOM TreeWalker**（快速）
2. **结果映射回 ProseMirror 位置**（只在需要 replace 时）
3. **高亮用 CSS overlay**（无 dispatch）
4. **只在 replace 时调用 dispatch**

---

## 六、结论

| 问题 | 答案 |
|------|------|
| 问题出在哪？ | `doc.descendants()` + `dispatch(tr)` + `DecorationSet.create()` |
| 能否解决？ | ✅ 可以，但需要重写搜索架构 |
| 为什么插件能解决？ | 完全绕开 ProseMirror，直接操作 DOM |
| 为什么原生不行？ | 官方代码耦合 ProseMirror 状态管理 |

**核心洞察**：官方搜索的设计目标是**正确性**（精确位置、支持撤销），而非**性能**。对于大文档需要根本性架构改变。

---

## 七、PR 建议

若要提交 PR，建议采用**渐进式优化**：

1. **Phase 1**：增加 debounce（300ms）+ 结果数量限制
2. **Phase 2**：分离 UI 更新和搜索逻辑
3. **Phase 3**：CSS overlay 高亮（不用 Decoration）
4. **Phase 4**：DOM TreeWalker 搜索 + 按需位置映射

每个 Phase 独立可测试，风险可控。

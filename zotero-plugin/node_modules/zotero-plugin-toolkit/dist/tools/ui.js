import { BasicTool } from "../basic.js";
/**
 * UI APIs. Create elements and manage them.
 */
export class UITool extends BasicTool {
    get basicOptions() {
        return this._basicOptions;
    }
    /**
     * Store elements created with this instance
     *
     * @remarks
     * > What is this for?
     *
     * In bootstrap plugins, elements must be manually maintained and removed on exiting.
     *
     * This API does this for you.
     */
    elementCache;
    constructor(base) {
        super(base);
        this.elementCache = [];
        if (!this._basicOptions.ui) {
            this._basicOptions.ui = {
                enableElementRecord: true,
                enableElementJSONLog: false,
                enableElementDOMLog: true,
            };
        }
    }
    /**
     * Remove all elements created by `createElement`.
     *
     * @remarks
     * > What is this for?
     *
     * In bootstrap plugins, elements must be manually maintained and removed on exiting.
     *
     * This API does this for you.
     */
    unregisterAll() {
        this.elementCache.forEach((e) => {
            try {
                e?.deref()?.remove();
            }
            catch (e) {
                this.log(e);
            }
        });
    }
    createElement(...args) {
        const doc = args[0];
        const tagName = args[1].toLowerCase();
        let props = args[2] || {};
        if (!tagName) {
            return;
        }
        // string, use the old create
        if (typeof args[2] === "string") {
            props = {
                namespace: args[2],
                enableElementRecord: args[3],
            };
        }
        if ((typeof props.enableElementJSONLog !== "undefined" &&
            props.enableElementJSONLog) ||
            this.basicOptions.ui.enableElementJSONLog) {
            this.log(props);
        }
        //
        props.properties = props.properties || props.directAttributes;
        props.children = props.children || props.subElementOptions;
        let elem;
        if (tagName === "fragment") {
            const fragElem = doc.createDocumentFragment();
            elem = fragElem;
        }
        else {
            let realElem = (props.id &&
                (props.checkExistenceParent
                    ? props.checkExistenceParent
                    : doc).querySelector(`#${props.id}`));
            if (realElem && props.ignoreIfExists) {
                return realElem;
            }
            if (realElem && props.removeIfExists) {
                realElem.remove();
                realElem = undefined;
            }
            if (props.customCheck && !props.customCheck(doc, props)) {
                return undefined;
            }
            if (!realElem || !props.skipIfExists) {
                let namespace = props.namespace;
                if (!namespace) {
                    // eslint-disable-next-line ts/no-use-before-define
                    const mightHTML = HTMLElementTagNames.includes(tagName);
                    // eslint-disable-next-line ts/no-use-before-define
                    const mightXUL = XULElementTagNames.includes(tagName);
                    // eslint-disable-next-line ts/no-use-before-define
                    const mightSVG = SVGElementTagNames.includes(tagName);
                    if (Number(mightHTML) + Number(mightXUL) + Number(mightSVG) > 1) {
                        this.log(`[Warning] Creating element ${tagName} with no namespace specified. Found multiply namespace matches.`);
                    }
                    if (mightHTML) {
                        namespace = "html";
                    }
                    else if (mightXUL) {
                        namespace = "xul";
                    }
                    else if (mightSVG) {
                        namespace = "svg";
                    }
                    else {
                        namespace = "html";
                    }
                }
                if (namespace === "xul") {
                    realElem = this.createXULElement(doc, tagName);
                }
                else {
                    realElem = doc.createElementNS({
                        html: "http://www.w3.org/1999/xhtml",
                        svg: "http://www.w3.org/2000/svg",
                    }[namespace], tagName);
                }
                if (typeof props.enableElementRecord !== "undefined"
                    ? props.enableElementRecord
                    : this.basicOptions.ui.enableElementRecord) {
                    this.elementCache.push(new WeakRef(realElem));
                }
            }
            if (props.id) {
                realElem.id = props.id;
            }
            if (props.styles && Object.keys(props.styles).length) {
                Object.keys(props.styles).forEach((k) => {
                    const v = props.styles[k];
                    typeof v !== "undefined" && (realElem.style[k] = v);
                });
            }
            if (props.properties && Object.keys(props.properties).length) {
                Object.keys(props.properties).forEach((k) => {
                    const v = props.properties[k];
                    typeof v !== "undefined" && (realElem[k] = v);
                });
            }
            if (props.attributes && Object.keys(props.attributes).length) {
                Object.keys(props.attributes).forEach((k) => {
                    const v = props.attributes[k];
                    typeof v !== "undefined" && realElem.setAttribute(k, String(v));
                });
            }
            // Add classes after attributes, as user may set the class attribute
            if (props.classList?.length) {
                realElem.classList.add(...props.classList);
            }
            if (props.listeners?.length) {
                props.listeners.forEach(({ type, listener, options }) => {
                    listener && realElem.addEventListener(type, listener, options);
                });
            }
            elem = realElem;
        }
        if (props.children?.length) {
            const subElements = props.children
                .map((childProps) => {
                childProps.namespace = childProps.namespace || props.namespace;
                return this.createElement(doc, childProps.tag, childProps);
            })
                .filter((e) => e);
            elem.append(...subElements);
        }
        if (typeof props.enableElementDOMLog !== "undefined"
            ? props.enableElementDOMLog
            : this.basicOptions.ui.enableElementDOMLog) {
            this.log(elem);
        }
        return elem;
    }
    /**
     * Append element(s) to a node.
     * @param properties See {@link ElementProps}
     * @param container The parent node to append to.
     * @returns A Node that is the appended child (aChild),
     *          except when aChild is a DocumentFragment,
     *          in which case the empty DocumentFragment is returned.
     */
    appendElement(properties, container) {
        return container.appendChild(this.createElement(container.ownerDocument, properties.tag, properties));
    }
    /**
     * Inserts a node before a reference node as a child of its parent node.
     * @param properties See {@link ElementProps}
     * @param referenceNode The node before which newNode is inserted.
     * @returns Node
     */
    insertElementBefore(properties, referenceNode) {
        if (referenceNode.parentNode)
            return referenceNode.parentNode.insertBefore(this.createElement(referenceNode.ownerDocument, properties.tag, properties), referenceNode);
        else
            this.log(`${referenceNode.tagName} has no parent, cannot insert ${properties.tag}`);
    }
    /**
     * Replace oldNode with a new one.
     * @param properties See {@link ElementProps}
     * @param oldNode The child to be replaced.
     * @returns The replaced Node. This is the same node as oldChild.
     */
    replaceElement(properties, oldNode) {
        if (oldNode.parentNode)
            return oldNode.parentNode.replaceChild(this.createElement(oldNode.ownerDocument, properties.tag, properties), oldNode);
        else
            this.log(`${oldNode.tagName} has no parent, cannot replace it with ${properties.tag}`);
    }
    /**
     * Parse XHTML to XUL fragment. For Zotero 6.
     *
     * To load preferences from a Zotero 7's `.xhtml`, use this method to parse it.
     * @param str xhtml raw text
     * @param entities dtd file list ("chrome://xxx.dtd")
     * @param defaultXUL true for default XUL namespace
     */
    parseXHTMLToFragment(str, entities = [], defaultXUL = true) {
        // Adapted from MozXULElement.parseXULToFragment
        const parser = new DOMParser();
        const xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
        const htmlns = "http://www.w3.org/1999/xhtml";
        const wrappedStr = `${entities.length
            ? `<!DOCTYPE bindings [ ${entities.reduce((preamble, url, index) => {
                return `${preamble}<!ENTITY % _dtd-${index} SYSTEM "${url}"> %_dtd-${index}; `;
            }, "")}]>`
            : ""}
      <html:div xmlns="${defaultXUL ? xulns : htmlns}"
          xmlns:xul="${xulns}" xmlns:html="${htmlns}">
      ${str}
      </html:div>`;
        this.log(wrappedStr, parser);
        const doc = parser.parseFromString(wrappedStr, "text/xml");
        this.log(doc);
        if (doc.documentElement.localName === "parsererror") {
            throw new Error("not well-formed XHTML");
        }
        // We use a range here so that we don't access the inner DOM elements from
        // JavaScript before they are imported and inserted into a document.
        const range = doc.createRange();
        range.selectNodeContents(doc.querySelector("div"));
        return range.extractContents();
    }
}
const HTMLElementTagNames = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "menu",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "slot",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
];
const XULElementTagNames = [
    "action",
    "arrowscrollbox",
    "bbox",
    "binding",
    "bindings",
    "box",
    "broadcaster",
    "broadcasterset",
    "button",
    "browser",
    "checkbox",
    "caption",
    "colorpicker",
    "column",
    "columns",
    "commandset",
    "command",
    "conditions",
    "content",
    "deck",
    "description",
    "dialog",
    "dialogheader",
    "editor",
    "grid",
    "grippy",
    "groupbox",
    "hbox",
    "iframe",
    "image",
    "key",
    "keyset",
    "label",
    "listbox",
    "listcell",
    "listcol",
    "listcols",
    "listhead",
    "listheader",
    "listitem",
    "member",
    "menu",
    "menubar",
    "menuitem",
    "menulist",
    "menupopup",
    "menuseparator",
    "observes",
    "overlay",
    "page",
    "popup",
    "popupset",
    "preference",
    "preferences",
    "prefpane",
    "prefwindow",
    "progressmeter",
    "radio",
    "radiogroup",
    "resizer",
    "richlistbox",
    "richlistitem",
    "row",
    "rows",
    "rule",
    "script",
    "scrollbar",
    "scrollbox",
    "scrollcorner",
    "separator",
    "spacer",
    "splitter",
    "stack",
    "statusbar",
    "statusbarpanel",
    "stringbundle",
    "stringbundleset",
    "tab",
    "tabbrowser",
    "tabbox",
    "tabpanel",
    "tabpanels",
    "tabs",
    "template",
    "textnode",
    "textbox",
    "titlebar",
    "toolbar",
    "toolbarbutton",
    "toolbargrippy",
    "toolbaritem",
    "toolbarpalette",
    "toolbarseparator",
    "toolbarset",
    "toolbarspacer",
    "toolbarspring",
    "toolbox",
    "tooltip",
    "tree",
    "treecell",
    "treechildren",
    "treecol",
    "treecols",
    "treeitem",
    "treerow",
    "treeseparator",
    "triple",
    "vbox",
    "window",
    "wizard",
    "wizardpage",
];
const SVGElementTagNames = [
    "a",
    "animate",
    "animateMotion",
    "animateTransform",
    "circle",
    "clipPath",
    "defs",
    "desc",
    "ellipse",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "filter",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "script",
    "set",
    "stop",
    "style",
    "svg",
    "switch",
    "symbol",
    "text",
    "textPath",
    "title",
    "tspan",
    "use",
    "view",
];
/* cspell:enable */
//# sourceMappingURL=ui.js.map
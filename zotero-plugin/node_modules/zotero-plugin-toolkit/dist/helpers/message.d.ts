type MessageParams<T extends MessageHandlers> = {
    [K in keyof T]: T[K] extends (...params: infer P) => void ? P : never;
};
type MessageReturnType<T extends MessageHandlers> = {
    [K in keyof T]: T[K] extends (...params: any) => infer R ? R : never;
};
interface MessageHandlers {
    [key: string]: (...data: any[]) => Promise<any> | any;
}
type PromisedMessageHandlers<T extends MessageHandlers> = {
    [K in keyof T]: (...data: Parameters<T[K]>) => Promise<Awaited<ReturnType<T[K]>>>;
};
interface MessageServerConfig {
    name: string;
    handlers: MessageHandlers;
    target?: Window | Worker;
    dev?: boolean;
    canBeDestroyed?: boolean;
}
interface BuiltInMessageHandlers {
    _start: () => Promise<void>;
    _stop: () => Promise<void>;
    _destroy: () => Promise<void>;
    _ping: () => Promise<void>;
    _call: (data: {
        func: string;
        args: any[];
    }) => Promise<any>;
    _get: (data: {
        key: string;
    }) => Promise<any>;
    _set: (data: {
        key: string;
        value: any;
    }) => Promise<void>;
}
/**
 * Helper class to manage messages between workers/iframes and their parent
 * @beta
 *
 * @example
 * Use the `MessageHelper` to create a server that can be used to communicate between workers or iframes and their parent.
 *
 * In the child `worker.js`:
 * ```typescript
 * const handlers = {
 *   async test() {
 *     return "test";
 *   },
 * };
 * // Create a new server
 * const server = new MessageHelper({
 *   name: "child",
 *   handlers,
 *   canBeDestroyed: true,
 * });
 * // Start the listener
 * server.start();
 * // Export the handlers for type hinting
 * export { handlers };
 * ```
 * In the parent:
 * ```typescript
 * // Import the handlers
 * import type { handlers } from "./worker.js";
 * // Create a new worker
 * const worker = new Worker("worker.js");
 * // Create a new server with the type from the target handlers
 * const server = new MessageHelper<typeof handlers>({
 *   name: "worker",
 *   handlers: {
 *     async test() {
 *       return "test";
 *     },
 *   },
 *   target: worker,
 * });
 * server.start();
 * // Execute the handlers defined in the worker as if they were local
 * ztoolkit.log(await server.proxy.test());
 * // ...
 * // Stop the server, can be restarted with server.start()
 * server.stop();
 * // Destroy the server and the worker
 * server.destroy();
 * ```
 *
 * @example
 * Evaluate code in the other side of the server
 * ```typescript
 * await server.eval("self.firstName = 'John';");
 * ```
 *
 * @example
 * Get a property from the other side of the server, can be nested.
 *
 * Only works if the property is a primitive or a serializable object
 * ```typescript
 * ztoolkit.log(await server.get("self.firstName"));
 * ```
 *
 * @example
 * Set a property from the other side of the server, can be nested.
 *
 * Only works if the property is a primitive or a serializable object
 * ```typescript
 * await server.set("self.firstName", "Alice");
 * ```
 *
 * @example
 * Check if the target is alive
 * ```typescript
 * ztoolkit.log(await server.isTargetAlive());
 * // Alternatively, send a ping message
 * ztoolkit.log(await server.proxy._ping());
 * ```
 */
export declare class MessageHelper<_TargetHandlers extends MessageHandlers> {
    protected config: Required<MessageServerConfig>;
    protected env: "webworker" | "chromeworker" | "browser" | "content";
    protected listener?: any;
    running: boolean;
    /**
     * Proxy object to call the message handlers
     */
    proxy: PromisedMessageHandlers<_TargetHandlers & BuiltInMessageHandlers>;
    get target(): Window | Worker;
    get privileged(): boolean;
    constructor(config: MessageServerConfig);
    start(): void;
    stop(): void;
    destroy(): void;
    exec<_HandlersName extends keyof MessageParams<_HandlersType>, _HandlersType extends _TargetHandlers & BuiltInMessageHandlers>(name: _HandlersName, params?: MessageParams<_HandlersType>[_HandlersName], options?: {
        timeout?: number;
    }): Promise<Awaited<MessageReturnType<_HandlersType>[_HandlersName]>>;
    call(func: string, args: any[]): Promise<MessageReturnType<_TargetHandlers & BuiltInMessageHandlers>["_call"]>;
    get(key: string): Promise<MessageReturnType<_TargetHandlers & BuiltInMessageHandlers>["_get"]>;
    set(key: string, value: any): Promise<MessageReturnType<_TargetHandlers & BuiltInMessageHandlers>["_set"]>;
    eval(code: string): Promise<MessageReturnType<_TargetHandlers & BuiltInMessageHandlers>["_eval"]>;
    send(options: {
        name: string;
        data: any;
        jobID?: string;
        success?: boolean;
        requestReturn?: boolean;
    }): Promise<string>;
    isTargetAlive(): Promise<boolean>;
}
export {};
//# sourceMappingURL=message.d.ts.map
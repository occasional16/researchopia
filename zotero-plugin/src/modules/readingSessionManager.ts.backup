/**
 * 文献共读会话管理器
 * 负责创建、加入、管理文献共读会话，实现实时标注同步
 */

import { logger } from "../utils/logger";
import { AuthManager } from "./auth";

// Supabase 配置
const SUPABASE_URL = 'https://obcblvdtqhwrihoddlez.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9iY2JsdmR0cWh3cmlob2RkbGV6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc0OTgyMzUsImV4cCI6MjA3MzA3NDIzNX0.0kYlpFuK5WrKvUhIj7RO4-XJgv1sm39FROD_mBtxYm4';

// 辅助函数：获取token
function getToken(): string | null {
  const session = AuthManager.getSession();
  return session?.access_token || null;
}

// 辅助函数：获取当前用户
function getCurrentUser(): any {
  return AuthManager.getCurrentUser();
}

/**
 * 共读会话数据结构
 */
export interface ReadingSession {
  id: string;
  paper_doi: string;
  paper_title: string;
  session_type: 'public' | 'private';
  invite_code: string;
  creator_id: string;
  max_participants: number;
  is_active: boolean;
  settings: Record<string, any>;
  created_at: string;
  ended_at?: string;
}

/**
 * 会话成员数据结构
 */
export interface SessionMember {
  id: string;
  session_id: string;
  user_id: string;
  role: 'host' | 'participant';
  joined_at: string;
  last_seen: string;
  current_page: number;
  is_online: boolean;
  user_email?: string;
  user_name?: string;
  avatar_url?: string;
}

/**
 * 会话标注数据结构
 */
export interface SessionAnnotation {
  id: string;
  session_id: string;
  user_id: string;
  paper_doi: string;
  annotation_data: any;
  page_number: number;
  created_at: string;
  updated_at: string;
  user_email?: string;
  user_name?: string;
  avatar_url?: string;
}

/**
 * 实时标注事件
 */
export interface RealtimeAnnotationEvent {
  type: 'annotation_created' | 'annotation_updated' | 'annotation_deleted';
  annotation: SessionAnnotation;
  user_id: string;
}

/**
 * 实时在线状态事件
 */
export interface RealtimePresenceEvent {
  type: 'user_joined' | 'user_left' | 'user_page_changed';
  user_id: string;
  user_email?: string;
  user_name?: string;
  current_page?: number;
  member?: SessionMember;
}

/**
 * 文献共读会话管理器
 */
export class ReadingSessionManager {
  private static instance: ReadingSessionManager | null = null;
  private currentSession: ReadingSession | null = null;
  private currentMember: SessionMember | null = null;
  private zoteroNotifierID: string | null = null;
  
  private realtimeConnection: any = null;
  private heartbeatInterval: any = null;
  private pollingInterval: any = null;
  
  private annotationListeners: ((event: RealtimeAnnotationEvent) => void)[] = [];
  private presenceListeners: ((event: RealtimePresenceEvent) => void)[] = [];
  private memberListeners: ((members: SessionMember[]) => void)[] = [];
  
  private membersCache: Map<string, SessionMember[]> = new Map();
  private membersCacheExpiry: Map<string, number> = new Map();
  
  private lastAnnotationCheck: Date = new Date();
  private lastMembersCheck: Date = new Date();

  private constructor() {
    logger.log("[ReadingSessionManager] 📚 Initializing...");
  }

  public static getInstance(): ReadingSessionManager {
    if (!ReadingSessionManager.instance) {
      ReadingSessionManager.instance = new ReadingSessionManager();
    }
    return ReadingSessionManager.instance;
  }

  /**
   * 创建共读会话
   */
  public async createSession(
    paperDOI: string,
    paperTitle: string,
    sessionType: 'public' | 'private' = 'private',
    maxParticipants: number = 10
  ): Promise<{ session: ReadingSession; inviteCode: string }> {
    logger.log(`[ReadingSessionManager] 创建会话: ${paperTitle}`);
    
    const token = getToken();
    const user = getCurrentUser();
    
    if (!token) {
      throw new Error('未登录，无法创建会话');
    }

    try {
      // 调用数据库函数生成邀请码
      const inviteCodeResult = await this.apiRequest('rpc/generate_invite_code', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      const inviteCode = inviteCodeResult;

      // 创建会话记录
      const sessionData = {
        paper_doi: paperDOI,
        paper_title: paperTitle,
        session_type: sessionType,
        invite_code: inviteCode,
        creator_id: user?.id,
        max_participants: maxParticipants,
        is_active: true,
        settings: {},
      };

      const sessionResult = await this.apiRequest('reading_sessions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=representation',
        },
        body: JSON.stringify(sessionData),
      });

      const newSession: ReadingSession = Array.isArray(sessionResult) 
        ? sessionResult[0] 
        : sessionResult;

      // 自动加入会话（创建者角色为host）
      await this.joinSession(newSession.id, 'host');

      logger.log(`[ReadingSessionManager] ✅ 会话创建成功: ${newSession.id}`);
      
      return { session: newSession, inviteCode };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      logger.error(`[ReadingSessionManager] 创建会话失败: ${errorMsg}`);
      throw error;
    }
  }

  /**
   * 通过邀请码加入会话
   */
  public async joinSessionByInviteCode(inviteCode: string): Promise<ReadingSession> {
    logger.log(`[ReadingSessionManager] 通过邀请码加入会话: ${inviteCode}`);
    
    const token = getToken();
    
    if (!token) {
      throw new Error('未登录，无法加入会话');
    }

    try {
      // 查询会话
      const sessionsResult = await this.apiRequest(
        `reading_sessions?invite_code=eq.${inviteCode}&is_active=eq.true`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        }
      );

      if (!sessionsResult || sessionsResult.length === 0) {
        throw new Error('无效的邀请码或会话已结束');
      }

      const foundSession: ReadingSession = sessionsResult[0];

      // 检查会话是否满员
      const membersCount = await this.getSessionMembersCount(foundSession.id);
      if (membersCount >= foundSession.max_participants) {
        throw new Error('会话已满员');
      }

      // 加入会话
      await this.joinSession(foundSession.id, 'participant');

      logger.log(`[ReadingSessionManager] ✅ 成功加入会话: ${foundSession.id}`);
      
      return foundSession;
    } catch (error) {
      logger.error('[ReadingSessionManager] 加入会话失败:', error);
      throw error;
    }
  }

  /**
   * 加入会话（内部方法）
   */
  private async joinSession(sessionId: string, role: 'host' | 'participant'): Promise<void> {
    const token = getToken();
    const user = getCurrentUser();
    const userId = user?.id;

    if (!token || !userId) {
      throw new Error('未登录');
    }

    // 检查是否已经是成员
    const existingMember = await this.apiRequest(
      `session_members?session_id=eq.${sessionId}&user_id=eq.${userId}`,
      {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (existingMember && existingMember.length > 0) {
      // 已经是成员，更新在线状态
      this.currentMember = existingMember[0];
      await this.updateOnlineStatus(true);
      
      // 获取会话信息
      const sessionResult = await this.apiRequest(
        `reading_sessions?id=eq.${sessionId}`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        }
      );
      this.currentSession = sessionResult[0];
    } else {
      // 创建成员记录
      const memberData = {
        session_id: sessionId,
        user_id: userId,
        role: role,
        is_online: true,
        current_page: 1,
      };

      const memberResult = await this.apiRequest('session_members', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=representation',
        },
        body: JSON.stringify(memberData),
      });

      this.currentMember = Array.isArray(memberResult) ? memberResult[0] : memberResult;

      // 获取会话信息
      const sessionResult = await this.apiRequest(
        `reading_sessions?id=eq.${sessionId}`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        }
      );
      this.currentSession = sessionResult[0];
    }

    // 订阅实时事件
    await this.subscribeToRealtimeEvents();

    // 启动心跳
    this.startHeartbeat();

    // 注册Zotero标注监听器
    this.registerZoteroAnnotationListener();

    // 触发用户加入事件
    this.notifyPresenceListeners({
      type: 'user_joined',
      user_id: userId,
      user_email: user?.email,
      member: this.currentMember || undefined,
    });
  }

  /**
   * 离开当前会话
   */
  public async leaveSession(): Promise<void> {
    if (!this.currentSession || !this.currentMember) {
      logger.warn('[ReadingSessionManager] 没有活跃的会话');
      return;
    }

    logger.log(`[ReadingSessionManager] 离开会话: ${this.currentSession.id}`);

    try {
      this.stopHeartbeat();
      this.unregisterZoteroAnnotationListener(); // 注销标注监听器
      await this.unsubscribeFromRealtimeEvents();
      await this.updateOnlineStatus(false);

      const user = getCurrentUser();
      this.notifyPresenceListeners({
        type: 'user_left',
        user_id: user?.id || '',
        user_email: user?.email,
      });

      this.currentSession = null;
      this.currentMember = null;

      logger.log('[ReadingSessionManager] ✅ 已离开会话');
    } catch (error) {
      logger.error('[ReadingSessionManager] 离开会话失败:', error);
      throw error;
    }
  }

  /**
   * 获取当前用户的会话列表
   */
  public async getMySessions(): Promise<ReadingSession[]> {
    logger.log('[ReadingSessionManager] 获取我的会话列表');
    
    const token = getToken();
    const user = getCurrentUser();
    const userId = user?.id;
    
    if (!token || !userId) {
      throw new Error('未登录');
    }

    try {
      // 直接查询用户创建的会话，避免触发RLS递归
      const sessionsResult = await this.apiRequest(
        `reading_sessions?creator_id=eq.${userId}&is_active=eq.true&order=created_at.desc`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        }
      );

      return sessionsResult || [];
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      logger.error(`[ReadingSessionManager] 获取会话列表失败: ${errorMsg}`);
      return [];
    }
  }

  /**
   * 获取会话成员列表
   */
  public async getSessionMembers(
    sessionId: string,
    useCache: boolean = true
  ): Promise<SessionMember[]> {
    if (useCache) {
      const cached = this.membersCache.get(sessionId);
      const expiry = this.membersCacheExpiry.get(sessionId);
      if (cached && expiry && Date.now() < expiry) {
        return cached;
      }
    }

    const token = getToken();
    
    if (!token) {
      throw new Error('未登录');
    }

    try {
      const membersResult = await this.apiRequest(
        `session_members?session_id=eq.${sessionId}&select=*,users:user_id(email,username,avatar_url)`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        }
      );

      const members: SessionMember[] = (membersResult || []).map((m: any) => ({
        ...m,
        user_email: m.users?.email,
        user_name: m.users?.username || m.users?.email,
        avatar_url: m.users?.avatar_url,
      }));

      this.membersCache.set(sessionId, members);
      this.membersCacheExpiry.set(sessionId, Date.now() + 5000);

      return members;
    } catch (error) {
      logger.error('[ReadingSessionManager] 获取成员列表失败:', error);
      throw error;
    }
  }

  /**
   * 获取会话成员数量
   */
  private async getSessionMembersCount(sessionId: string): Promise<number> {
    const token = getToken();
    
    if (!token) {
      return 0;
    }

    try {
      const result = await this.apiRequest(
        `session_members?session_id=eq.${sessionId}&select=count`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Prefer': 'count=exact',
          },
        }
      );

      return result?.length || 0;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      logger.error(`[ReadingSessionManager] 获取成员数量失败: ${errorMsg}`);
      return 0;
    }
  }

  /**
   * 创建会话标注
   */
  public async createAnnotation(
    annotationData: any,
    pageNumber: number
  ): Promise<SessionAnnotation> {
    if (!this.currentSession || !this.currentMember) {
      throw new Error('没有活跃的会话');
    }

    logger.log(`[ReadingSessionManager] 创建标注: page ${pageNumber}`);

    const token = getToken();
    const user = getCurrentUser();
    const userId = user?.id;
    
    if (!token || !userId) {
      throw new Error('未登录');
    }

    try {
      const data = {
        session_id: this.currentSession.id,
        user_id: userId,
        paper_doi: this.currentSession.paper_doi,
        annotation_data: annotationData,
        page_number: pageNumber,
      };

      const result = await this.apiRequest('session_annotations', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=representation',
        },
        body: JSON.stringify(data),
      });

      const annotation: SessionAnnotation = Array.isArray(result) ? result[0] : result;

      annotation.user_email = user?.email;
      annotation.user_name = user?.username || user?.email;

      logger.log(`[ReadingSessionManager] ✅ 标注创建成功: ${annotation.id}`);

      return annotation;
    } catch (error) {
      logger.error('[ReadingSessionManager] 创建标注失败:', error);
      throw error;
    }
  }

  /**
   * 获取会话标注列表
   */
  public async getSessionAnnotations(
    sessionId: string,
    page: number = 1,
    pageSize: number = 50
  ): Promise<SessionAnnotation[]> {
    const token = getToken();
    
    if (!token) {
      throw new Error('未登录');
    }

    try {
      const from = (page - 1) * pageSize;
      const to = from + pageSize - 1;

      const result = await this.apiRequest(
        `session_annotations?session_id=eq.${sessionId}&select=*,users:user_id(email,username,avatar_url)&order=created_at.desc`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Range': `${from}-${to}`,
          },
        }
      );

      const annotations: SessionAnnotation[] = (result || []).map((a: any) => ({
        ...a,
        user_email: a.users?.email,
        user_name: a.users?.username || a.users?.email,
        avatar_url: a.users?.avatar_url,
      }));

      return annotations;
    } catch (error) {
      logger.error('[ReadingSessionManager] 获取标注列表失败:', error);
      throw error;
    }
  }

  /**
   * 更新当前页码
   */
  public async updateCurrentPage(pageNumber: number): Promise<void> {
    if (!this.currentMember) {
      return;
    }

    const token = getToken();
    
    if (!token) {
      return;
    }

    try {
      await this.apiRequest(`session_members?id=eq.${this.currentMember.id}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          current_page: pageNumber,
          last_seen: new Date().toISOString(),
        }),
      });

      this.currentMember.current_page = pageNumber;

      const user = getCurrentUser();
      this.notifyPresenceListeners({
        type: 'user_page_changed',
        user_id: user?.id || '',
        current_page: pageNumber,
      });
    } catch (error) {
      logger.error('[ReadingSessionManager] 更新页码失败:', error);
    }
  }

  /**
   * 更新在线状态
   */
  private async updateOnlineStatus(isOnline: boolean): Promise<void> {
    if (!this.currentMember) {
      return;
    }

    const token = getToken();
    
    if (!token) {
      return;
    }

    try {
      await this.apiRequest(`session_members?id=eq.${this.currentMember.id}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          is_online: isOnline,
          last_seen: new Date().toISOString(),
        }),
      });

      this.currentMember.is_online = isOnline;
    } catch (error) {
      logger.error('[ReadingSessionManager] 更新在线状态失败:', error);
    }
  }

  /**
   * 订阅实时事件
   */
  private async subscribeToRealtimeEvents(): Promise<void> {
    if (!this.currentSession) {
      return;
    }

    logger.log(`[ReadingSessionManager] 订阅实时事件: ${this.currentSession.id}`);

    // 启动轮询
    this.startPolling();
  }

  /**
   * 取消订阅实时事件
   */
  private async unsubscribeFromRealtimeEvents(): Promise<void> {
    logger.log('[ReadingSessionManager] 取消订阅实时事件');

    this.stopPolling();

    if (this.realtimeConnection) {
      try {
        this.realtimeConnection.close();
      } catch (error) {
        logger.error('[ReadingSessionManager] 关闭连接失败:', error);
      }
      this.realtimeConnection = null;
    }
  }

  /**
   * 启动轮询
   */
  private startPolling(): void {
    if (this.pollingInterval) {
      return;
    }

    logger.log('[ReadingSessionManager] 启动轮询');

    this.pollingInterval = setInterval(async () => {
      try {
        await this.pollAnnotations();
        await this.pollMembers();
      } catch (error) {
        logger.error('[ReadingSessionManager] 轮询错误:', error);
      }
    }, 2000);
  }

  private stopPolling(): void {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
      logger.log('[ReadingSessionManager] 停止轮询');
    }
  }

  private async pollAnnotations(): Promise<void> {
    if (!this.currentSession) {
      return;
    }

    try {
      const token = getToken();
      
      if (!token) {
        return;
      }

      const result = await this.apiRequest(
        `session_annotations?session_id=eq.${this.currentSession.id}&created_at=gt.${this.lastAnnotationCheck.toISOString()}&select=*,users:user_id(email,username,avatar_url)&order=created_at.asc`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        }
      );

      if (result && result.length > 0) {
        for (const a of result) {
          const annotation: SessionAnnotation = {
            ...a,
            user_email: a.users?.email,
            user_name: a.users?.username || a.users?.email,
            avatar_url: a.users?.avatar_url,
          };

          this.notifyAnnotationListeners({
            type: 'annotation_created',
            annotation,
            user_id: a.user_id,
          });
        }

        this.lastAnnotationCheck = new Date();
      }
    } catch (error) {
      // 静默失败
    }
  }

  private async pollMembers(): Promise<void> {
    if (!this.currentSession) {
      return;
    }

    try {
      const members = await this.getSessionMembers(this.currentSession.id, false);
      this.notifyMemberListeners(members);
      this.lastMembersCheck = new Date();
    } catch (error) {
      // 静默失败
    }
  }

  /**
   * 启动心跳
   */
  private startHeartbeat(): void {
    if (this.heartbeatInterval) {
      return;
    }

    logger.log('[ReadingSessionManager] 启动心跳');

    this.heartbeatInterval = setInterval(async () => {
      try {
        await this.updateOnlineStatus(true);
      } catch (error) {
        logger.error('[ReadingSessionManager] 心跳错误:', error);
      }
    }, 30000);
  }

  /**
   * 停止心跳
   */
  private stopHeartbeat(): void {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
      logger.log('[ReadingSessionManager] 停止心跳');
    }
  }

  /**
   * 注册事件监听器
   */
  public onAnnotation(callback: (event: RealtimeAnnotationEvent) => void): void {
    this.annotationListeners.push(callback);
  }

  public onPresence(callback: (event: RealtimePresenceEvent) => void): void {
    this.presenceListeners.push(callback);
  }

  public onMembersChange(callback: (members: SessionMember[]) => void): void {
    this.memberListeners.push(callback);
  }

  /**
   * 注册Zotero标注监听器
   * 监听用户创建的标注并自动同步到会话
   */
  private registerZoteroAnnotationListener(): void {
    if (this.zoteroNotifierID) {
      // 已经注册过,先注销
      (Zotero as any).Notifier.unregisterObserver(this.zoteroNotifierID);
      this.zoteroNotifierID = null;
    }

    const notifierCallback = {
      notify: async (event: string, type: string, ids: any[], extraData: any) => {
        logger.log(`[ReadingSessionManager] 🔔 Notifier收到事件: event=${event}, type=${type}, ids=${ids}`);
        
        if (event === 'add' && type === 'item' && this.currentSession) {
          logger.log(`[ReadingSessionManager] 📋 处理标注添加事件, 当前会话: ${this.currentSession.id}`);
          // 检查是否是标注
          for (const id of ids) {
            try {
              const item = await (Zotero.Items as any).getAsync(id);
              logger.log(`[ReadingSessionManager] 📄 检查项目 ${id}: isAnnotation=${item?.isAnnotation()}`);
              
              if (!item || !item.isAnnotation()) continue;

              // 获取标注所在的PDF
              const parentItem = item.parentItem;
              logger.log(`[ReadingSessionManager] 📎 标注父项目:`, parentItem?.key);
              if (!parentItem) continue;

              // PDF附件没有DOI字段,需要从其父条目(文献条目)获取
              let doi = '';
              try {
                doi = parentItem.getField('DOI');
              } catch (e) {
                // PDF附件没有DOI字段,尝试获取其父条目的DOI
                const paperItem = parentItem.parentItem;
                if (paperItem) {
                  doi = paperItem.getField('DOI');
                  logger.log(`[ReadingSessionManager] � 从文献条目获取DOI: ${doi}`);
                }
              }
              
              logger.log(`[ReadingSessionManager] 🔍 文献DOI: ${doi}, 会话DOI: ${this.currentSession.paper_doi}`);
              if (!doi || doi !== this.currentSession.paper_doi) {
                logger.log(`[ReadingSessionManager] ⏭️ DOI不匹配,跳过此标注`);
                continue;
              }

              // 获取标注数据
              const annotationData = {
                key: item.key,
                type: item.annotationType,
                text: item.annotationText || '',
                comment: item.annotationComment || '',
                color: item.annotationColor || '',
                position: item.annotationPosition || null,
                tags: item.getTags().map((t: any) => t.tag),
              };

              // 获取页码
              const pageIndex = item.annotationPageLabel || '1';
              const pageNumber = parseInt(pageIndex) || 1;

              // 同步到会话
              await this.createAnnotation(annotationData, pageNumber);
              
              logger.log(`[ReadingSessionManager] ✅ 标注已自动同步到会话: ${item.key}`);
            } catch (error) {
              logger.error('[ReadingSessionManager] 标注同步失败:', error);
            }
          }
        }
      }
    };

    this.zoteroNotifierID = (Zotero as any).Notifier.registerObserver(notifierCallback, ['item']);
    logger.log('[ReadingSessionManager] ✅ Zotero标注监听器已注册');
  }

  /**
   * 注销Zotero标注监听器
   */
  private unregisterZoteroAnnotationListener(): void {
    if (this.zoteroNotifierID) {
      (Zotero as any).Notifier.unregisterObserver(this.zoteroNotifierID);
      this.zoteroNotifierID = null;
      logger.log('[ReadingSessionManager] ✅ Zotero标注监听器已注销');
    }
  }

  /**
   * 通知监听器
   */
  private notifyAnnotationListeners(event: RealtimeAnnotationEvent): void {
    for (const listener of this.annotationListeners) {
      try {
        listener(event);
      } catch (error) {
        logger.error('[ReadingSessionManager] 标注监听器错误:', error);
      }
    }
  }

  private notifyPresenceListeners(event: RealtimePresenceEvent): void {
    for (const listener of this.presenceListeners) {
      try {
        listener(event);
      } catch (error) {
        logger.error('[ReadingSessionManager] 在线状态监听器错误:', error);
      }
    }
  }

  private notifyMemberListeners(members: SessionMember[]): void {
    for (const listener of this.memberListeners) {
      try {
        listener(members);
      } catch (error) {
        logger.error('[ReadingSessionManager] 成员监听器错误:', error);
      }
    }
  }

  /**
   * Getter方法
   */
  public getCurrentSession(): ReadingSession | null {
    return this.currentSession;
  }

  public getCurrentMember(): SessionMember | null {
    return this.currentMember;
  }

  public isInSession(): boolean {
    return this.currentSession !== null && this.currentMember !== null;
  }

  /**
   * API请求辅助方法
   */
  private async apiRequest(endpoint: string, options: any = {}): Promise<any> {
    const url = `${SUPABASE_URL}/rest/v1/${endpoint}`;
    
    const defaultHeaders = {
      'apikey': SUPABASE_ANON_KEY,
      'Content-Type': 'application/json',
    };

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          ...defaultHeaders,
          ...options.headers,
        },
      });

      if (!response.ok) {
        const errorText = await response.text();
        const errorMsg = `API请求失败 [${response.status}]: ${errorText}`;
        logger.error(`[ReadingSessionManager] ${errorMsg}`);
        throw new Error(errorMsg);
      }

      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        return await response.json();
      }

      return await response.text();
    } catch (error) {
      if (error instanceof Error) {
        logger.error(`[ReadingSessionManager] API请求异常: ${error.message}`);
        throw error;
      }
      logger.error(`[ReadingSessionManager] API请求异常:`, error);
      throw new Error('API请求失败，请检查网络连接');
    }
  }

  /**
   * 清理资源
   */
  public async cleanup(): Promise<void> {
    logger.log('[ReadingSessionManager] 清理资源');
    
    if (this.isInSession()) {
      await this.leaveSession();
    }

    this.stopHeartbeat();
    this.stopPolling();
    
    this.annotationListeners = [];
    this.presenceListeners = [];
    this.memberListeners = [];
    this.membersCache.clear();
    this.membersCacheExpiry.clear();
  }
}


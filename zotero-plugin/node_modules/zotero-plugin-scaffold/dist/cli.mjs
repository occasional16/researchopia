import process from 'node:process';
import { Command } from 'commander';
import { E as ExitSignals, C as Config, B as Build, S as Serve, T as Test, R as Release } from './shared/zotero-plugin-scaffold.8gLns8GX.mjs';
import { readFile } from 'node:fs/promises';
import { pathExists } from 'fs-extra';
import { l as logger } from './shared/zotero-plugin-scaffold.CzBjWbS8.mjs';
import tinyUpdateNotifier from 'tiny-update-notifier';
import 'c12';
import 'es-toolkit';
import 'fs-extra/esm';
import 'hookable';
import 'tinyglobby';
import 'node:path';
import 'esbuild';
import '@fluent/syntax';
import 'node:fs';
import '@swc/core';
import 'node:crypto';
import 'adm-zip';
import 'node:child_process';
import 'std-env';
import 'bumpp';
import 'node:os';
import 'node:url';
import 'node:assert';
import 'node:v8';
import 'node:util';
import 'octokit';
import 'chokidar';
import 'node:net';
import 'node:buffer';
import 'node:domain';
import 'node:events';
import 'xvfb-ts';
import 'node:http';
import 'node:readline';

const name = "zotero-plugin-scaffold";
const version = "0.8.0";
const pkg = {
	name: name,
	version: version};

async function checkGitIgnore() {
  if (!pathExists(".git"))
    return;
  if (!pathExists(".gitignore")) {
    logger.warn("No .gitignore file found");
    return;
  }
  const contents = await readFile(".gitignore", "utf-8");
  const ignores = ["node_modules", ".env", ".scaffold"];
  const miss = ignores.filter((ignore) => !contents.match(ignore));
  if (miss.length !== 0)
    logger.warn(`We recommend adding the following to your .gitignore file: ${miss.join(", ")}`);
}

function updateNotifier(name, version) {
  tinyUpdateNotifier({ pkg: { name, version } }).then((update) => {
    if (update) {
      const notify = () => {
        logger.newLine();
        logger.info(`New version of ${update.name} available!`);
        logger.info(`Update: ${update.current} \u2192 ${update.latest} (${update.type})`);
        logger.newLine();
      };
      ExitSignals.forEach((sig) => process.once(sig, notify));
    }
  }).catch();
}

async function main() {
  const { name, version } = pkg;
  updateNotifier(name, version);
  process.env.NODE_ENV ??= "development";
  const cli = new Command();
  cli.version(version).usage("<command> [options]");
  cli.command("build").description("Build the plugin").option("--dev", "Builds the plugin in dev mode").option("--dist <dir>", "The relative path for the new output directory (default: build)").action(async (options) => {
    process.env.NODE_ENV = options.dev ? "development" : "production";
    await runCommand(Build, {
      dist: options.dist
    });
  });
  cli.command("serve").alias("dev").description("Start development server").action(async (_options) => {
    await runCommand(Serve, {});
  });
  cli.command("test").description("Run tests").option("--abort-on-fail", "Abort the test suite on first failure").option("--exit-on-finish", "Exit the test suite after all tests have run").option("--no-watch", "Exit the test suite after all tests have run").action(async (options) => {
    process.env.NODE_ENV = "test";
    await runCommand(Test, {
      test: {
        abortOnFail: options.abortOnFail,
        watch: !options.exitOnFinish && options.watch
      }
    });
  });
  cli.command("create").description("Create the plugin template").action(async (_options) => {
    logger.error("The create not yet implemented");
  });
  cli.command("release").description("Release the plugin").argument("[version]", "Target version: major, minor, patch, pre*, or specify version").option("--preid <preid>", "ID for prerelease").option("-y, --yes", "Skip confirmation").action(async (version2, options) => {
    process.env.NODE_ENV = "production";
    await runCommand(Release, {
      release: {
        bumpp: {
          release: version2,
          preid: options.preid,
          confirm: !options.yes
        }
      }
    });
  });
  cli.arguments("<command>").action((cmd) => {
    cli.outputHelp();
    logger.error(`Unknown command name "${cmd}".`);
  });
  cli.parse();
}
async function runCommand(CommandClass, config) {
  const ctx = await Config.loadConfig(config);
  const instance = new CommandClass(ctx);
  process.on("SIGINT", instance.exit.bind(instance));
  await instance.run();
}
async function mainWithErrorHandler() {
  main().then(() => {
    checkGitIgnore();
  }).catch(onError);
  process.on("uncaughtException", onError);
}
function onError(err) {
  logger.error(err);
  if (err.output) {
    logger.log(err.output.stderr);
  }
  process.exit(1);
}

export { mainWithErrorHandler as default, runCommand };

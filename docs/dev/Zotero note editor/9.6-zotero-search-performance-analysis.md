# 9.6 Zotero Note 搜索性能深度分析

## 核心问题

**为什么插件方案（更复杂）比官方方案（更原生）快？**

### 性能瓶颈根源

❌ **误解**: ProseMirror 的 `doc.descendants()` 是"更原生"的方法  
✅ **真相**: 它是**更抽象**的方法，性能更差

### 关键差异

| 维度 | TreeWalker (插件) | doc.descendants() (官方) |
|------|-------------------|--------------------------|
| **实现语言** | C++ (浏览器引擎) | JavaScript (ProseMirror) |
| **遍历对象** | 扁平 DOM 文本节点 | 抽象文档树 (AST) |
| **复杂度** | O(n) | O(n × m) - m=平均深度 |
| **节点开销** | 直接访问 textContent | 类型检查+位置计算+Schema验证 |
| **500k字符** | ~200ms | ~10000ms (50倍差距) |

## 技术原理

### TreeWalker 方案

```javascript
const walker = document.createTreeWalker(editorBody, NodeFilter.SHOW_TEXT);
while (textNode = walker.nextNode()) {
  const text = textNode.textContent; // 直接读取
  // 正则匹配...
}
```

**优势**:
- 浏览器底层 C++ 优化
- 只遍历已渲染的文本节点
- 无需递归，无需位置累加

### doc.descendants() 方案

```javascript
doc.descendants((node, pos) => {
  // 每个节点都要:
  // 1. 检查 node.type (Schema 查询)
  // 2. 计算 position (累加父节点偏移)
  // 3. 访问 node.text (通过 getter)
  // 4. 处理嵌套结构 (列表、引用、表格)
})
```

**劣势**:
- JavaScript 实现，比 C++ 慢 10-100 倍
- 维护文档逻辑结构，额外开销
- 每个节点多次函数调用

## 类比说明

就像比较:
- **C 语言遍历数组**: `for(int i=0; i<n; i++) arr[i]`
- **Python 遍历嵌套 JSON**: 递归解析多层字典和列表

后者虽然"功能更强大"，但就是慢！

## 优化方案

### 方案1: 混合方案（已实现）

```javascript
search(doc) {
  if (this.view && this.view.dom) {
    // 用 TreeWalker 搜索（快）
    const walker = document.createTreeWalker(...);
    while (textNode = walker.nextNode()) {
      // 映射 DOM 位置到 ProseMirror 位置
      const pos = this.view.posAtDOM(textNode, offset);
      this.results.push({ from: pos, to: pos + length });
    }
  }
}
```

**问题**: `posAtDOM()` 本身也是 JavaScript 实现，映射成本高

### 方案2: 纯 DOM 方案（插件使用）

```javascript
// 搜索: TreeWalker
// 高亮: CSS Overlay (不用 ProseMirror Decoration)
const overlay = document.createElement('div');
overlay.style.cssText = `position: absolute; left: ${x}px; top: ${y}px;`;
container.appendChild(overlay);
```

**优势**: 完全绕过 ProseMirror  
**劣势**: 无法提交官方 PR（架构不兼容）

### 方案3: 异步分批（可尝试）

```javascript
search(doc) {
  const batchSize = 100;
  let processed = 0;
  
  const processBatch = () => {
    // 处理 100 个节点
    if (processed < total) {
      requestIdleCallback(processBatch);
    }
  };
  
  requestIdleCallback(processBatch);
}
```

**优势**: 不阻塞 UI  
**劣势**: 实现复杂，结果延迟显示

## 结论

1. **架构设计 > 代码实现** - ProseMirror 的抽象层是性能瓶颈
2. **"原生"不等于"快"** - JavaScript 遍历 AST < C++ 遍历 DOM
3. **官方 PR 受限** - 必须保持 ProseMirror 架构，难以达到插件性能
4. **实用建议**: 个人使用继续用插件；官方 PR 可考虑限制搜索范围

## 参考

- 插件实现: `zotero-better-notes/src/modules/customSearch/findbar.ts`
- 官方代码: `note-editor/src/core/plugins/search.js`
- ProseMirror 文档: https://prosemirror.net/docs/ref/#model.Node.descendants

---

**文档版本**: v1.0  
**更新时间**: 2025-11-27  
**相关文档**: [9.2-zotero-note-search-optimization.md](./9.2-zotero-note-search-optimization.md)

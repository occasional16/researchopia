# 9.10 Note Editor 搜索性能问题可行性分析

## 核心结论

**✅ 官方源码的搜索卡顿问题可以解决**，之前的分析存在误判。

---

## 一、真正的性能瓶颈

### 1.1 官方代码流程分析

```javascript
// search.js - updateView() 方法 (核心问题所在)
updateView() {
    if (this.triggerUpdate) {
        this.triggerUpdate = false;
        let { state, dispatch } = this.view;
        let { tr } = state;
        
        // ⚠️ 问题1: 同步遍历整个文档
        this.search(tr.doc);
        
        // ⚠️ 问题2: 创建大量 Decoration 对象
        let list = this.results.map((deco, index) => (
            Decoration.inline(deco.from, deco.to, {...})
        ));
        this.decorations = DecorationSet.create(tr.doc, list);
        
        // ⚠️ 问题3: dispatch 触发全局渲染
        dispatch(tr);
    }
}
```

### 1.2 三重性能开销

| 阶段 | 操作 | 复杂度 | 耗时(500k字符) |
|------|------|--------|----------------|
| **搜索** | `doc.descendants()` + removeDiacritics | O(n) | ~300-500ms |
| **Decoration** | `DecorationSet.create()` | O(m log n) | ~100-200ms |
| **渲染** | `dispatch(tr)` 触发 DOM 更新 | O(m) | ~200-500ms |

n=节点数, m=匹配结果数

---

## 二、为什么插件能解决但原生"不行"？

### 2.1 插件方案回顾

```typescript
// customSearch/asyncEngine.ts
async searchAsync(content: string, options: SearchOptions) {
    return new Promise((resolve) => {
        setTimeout(() => {
            // 直接搜 HTML 文本，不走 ProseMirror
            const text = this.stripHtml(content);
            const results = this.searchSync(text, options);
            resolve(results);
        }, 0);
    });
}
```

**关键差异**：
- 插件：`直接操作 editor._item.note (HTML字符串)`
- 官方：`遍历 ProseMirror doc.descendants()`

### 2.2 之前分析的误区

9.9 文档结论："必须维护 ProseMirror 文档位置" - **这是错误的假设**

**真相**：
1. **搜索可以绕开 ProseMirror** - 用 DOM TreeWalker
2. **高亮可以绕开 DecorationSet** - 用 CSS overlay
3. **只有 replace 需要 ProseMirror 位置** - 可以按需计算

---

## 三、可行修复方案

### 方案A: 最小改动 (debounce + 限制)

```javascript
// 修改 setSearchTerm()
setSearchTerm(searchTerm) {
    this.searchTerm = searchTerm;
    this.triggerUpdate = true;
    
    // 添加 debounce
    clearTimeout(this._debounceTimer);
    this._debounceTimer = setTimeout(() => {
        dispatch(state.tr);
    }, 300);
}

// 修改 updateView() - 限制结果数
this.results = this.results.slice(0, 500); // 最多500个高亮
```

**效果**: 减少 60-70% 卡顿

### 方案B: CSS Overlay 高亮 (不改搜索逻辑)

```javascript
updateView() {
    this.search(tr.doc);
    
    // 不用 DecorationSet，改用 CSS overlay
    this.renderHighlightsWithCSS(this.results);
    
    // 只在需要时 dispatch (如 triggerFocus)
    if (this.triggerFocus) {
        dispatch(tr);
    }
}

renderHighlightsWithCSS(results) {
    // 清除旧的 overlay
    this.overlayContainer.innerHTML = '';
    
    results.forEach((result, index) => {
        const coords = this.view.coordsAtPos(result.from);
        const endCoords = this.view.coordsAtPos(result.to);
        
        const highlight = document.createElement('div');
        highlight.className = index === this.selectedResultIndex 
            ? 'find-selected-overlay' : 'find-overlay';
        highlight.style.cssText = `
            position: absolute;
            left: ${coords.left}px;
            top: ${coords.top}px;
            width: ${endCoords.right - coords.left}px;
            height: ${coords.bottom - coords.top}px;
        `;
        this.overlayContainer.appendChild(highlight);
    });
}
```

**效果**: 消除 DecorationSet 和 dispatch 开销

### 方案C: DOM TreeWalker 搜索 (彻底优化)

```javascript
search(doc) {
    // 用 DOM TreeWalker 替代 doc.descendants
    const walker = document.createTreeWalker(
        this.view.dom,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );
    
    this.results = [];
    const searchRe = this.buildRegex();
    
    let node;
    while (node = walker.nextNode()) {
        const text = node.textContent;
        let match;
        while (match = searchRe.exec(text)) {
            // 使用 Range 定位
            const range = document.createRange();
            range.setStart(node, match.index);
            range.setEnd(node, match.index + match[0].length);
            
            this.results.push({
                range,
                // 按需计算 ProseMirror 位置
                getPMPos: () => this.view.posAtDOM(node, match.index)
            });
        }
    }
}
```

**效果**: 搜索速度提升 5-10x

---

## 四、推荐实施路径

```
Phase 1 (低风险): debounce 300ms + 结果限制 500
    ↓ PR可接受度: ★★★★★
    
Phase 2 (中风险): CSS overlay 高亮
    ↓ PR可接受度: ★★★☆☆
    
Phase 3 (高风险): DOM TreeWalker 搜索 + 按需位置映射
    ↓ PR可接受度: ★★☆☆☆ (需要重写)
```

---

## 五、核心洞察

| 问题 | 答案 |
|------|------|
| 官方搜索为什么慢？ | 三重开销：doc.descendants + DecorationSet + dispatch |
| 能否解决？ | **✅ 可以**，方案A几乎不改架构 |
| 为什么插件能解决？ | 绕过 ProseMirror 直接搜 HTML |
| 9.9分析错在哪？ | 错误假设"必须走 ProseMirror"，实际只有 replace 需要 |

**关键认知突破**：
- 搜索/高亮 → 可以完全脱离 ProseMirror
- replace → 需要 ProseMirror 位置，但可以**按需计算**而非预存储

---

## 六、下一步行动

1. Fork zotero/note-editor
2. 实施 Phase 1 (debounce + 限制)
3. 本地测试 500k 字符文档
4. 提交 PR 并附上性能对比数据

**预期效果**: 
- Phase 1: 卡顿从 2-3s 降至 500ms-1s
- Phase 2+3: 实现毫秒级响应

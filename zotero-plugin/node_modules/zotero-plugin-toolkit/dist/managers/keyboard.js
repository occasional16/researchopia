import { ManagerTool } from "../basic.js";
import { waitForReader, waitUntil } from "../utils/wait.js";
/**
 * Register a global keyboard event listener.
 */
export class KeyboardManager extends ManagerTool {
    _keyboardCallbacks = new Set();
    _cachedKey;
    id;
    constructor(base) {
        super(base);
        this.id = `kbd-${Zotero.Utilities.randomString()}`;
        this._ensureAutoUnregisterAll();
        this.addListenerCallback("onMainWindowLoad", this.initKeyboardListener);
        this.addListenerCallback("onMainWindowUnload", this.unInitKeyboardListener);
        this.initReaderKeyboardListener();
        for (const win of Zotero.getMainWindows()) {
            this.initKeyboardListener(win);
        }
    }
    /**
     * Register a keyboard event listener.
     * @param callback The callback function.
     */
    register(callback) {
        this._keyboardCallbacks.add(callback);
    }
    /**
     * Unregister a keyboard event listener.
     * @param callback The callback function.
     */
    unregister(callback) {
        this._keyboardCallbacks.delete(callback);
    }
    /**
     * Unregister all keyboard event listeners.
     */
    unregisterAll() {
        this._keyboardCallbacks.clear();
        this.removeListenerCallback("onMainWindowLoad", this.initKeyboardListener);
        this.removeListenerCallback("onMainWindowUnload", this.unInitKeyboardListener);
        for (const win of Zotero.getMainWindows()) {
            this.unInitKeyboardListener(win);
        }
    }
    initKeyboardListener = this._initKeyboardListener.bind(this);
    unInitKeyboardListener = this._unInitKeyboardListener.bind(this);
    initReaderKeyboardListener() {
        Zotero.Reader.registerEventListener("renderToolbar", (event) => this.addReaderKeyboardCallback(event), this._basicOptions.api.pluginID);
        Zotero.Reader._readers.forEach((reader) => this.addReaderKeyboardCallback({ reader }));
    }
    async addReaderKeyboardCallback(event) {
        const reader = event.reader;
        const initializedKey = `_ztoolkitKeyboard${this.id}Initialized`;
        await waitForReader(reader);
        if (!reader._iframeWindow) {
            return;
        }
        if (reader._iframeWindow[initializedKey]) {
            return;
        }
        this._initKeyboardListener(reader._iframeWindow);
        waitUntil(() => !Components.utils.isDeadWrapper(reader._internalReader) &&
            reader._internalReader?._primaryView?._iframeWindow, () => this._initKeyboardListener(reader._internalReader._primaryView?._iframeWindow));
        reader._iframeWindow[initializedKey] = true;
    }
    _initKeyboardListener(win) {
        if (!win) {
            return;
        }
        win.addEventListener("keydown", this.triggerKeydown);
        win.addEventListener("keyup", this.triggerKeyup);
    }
    _unInitKeyboardListener(win) {
        if (!win) {
            return;
        }
        win.removeEventListener("keydown", this.triggerKeydown);
        win.removeEventListener("keyup", this.triggerKeyup);
    }
    triggerKeydown = (e) => {
        if (!this._cachedKey) {
            this._cachedKey = new KeyModifier(e);
        }
        else {
            this._cachedKey.merge(new KeyModifier(e), { allowOverwrite: false });
        }
        this.dispatchCallback(e, {
            type: "keydown",
        });
    };
    triggerKeyup = async (e) => {
        if (!this._cachedKey) {
            return;
        }
        const currentShortcut = new KeyModifier(this._cachedKey);
        this._cachedKey = undefined;
        this.dispatchCallback(e, {
            keyboard: currentShortcut,
            type: "keyup",
        });
    };
    dispatchCallback(...args) {
        this._keyboardCallbacks.forEach((cbk) => cbk(...args));
    }
}
/**
 * Class to represent key with modifiers
 */
export class KeyModifier {
    accel = false;
    shift = false;
    control = false;
    meta = false;
    alt = false;
    key = "";
    useAccel = false;
    constructor(raw, options) {
        this.useAccel = options?.useAccel || false;
        if (typeof raw === "undefined") {
            // ignore
        }
        else if (typeof raw === "string") {
            raw = raw || "";
            raw = this.unLocalized(raw);
            this.accel = raw.includes("accel");
            this.shift = raw.includes("shift");
            this.control = raw.includes("control");
            this.meta = raw.includes("meta");
            this.alt = raw.includes("alt");
            // Remove all modifiers, space, comma, and dash
            this.key = raw
                .replace(/(accel|shift|control|meta|alt|[ ,\-])/g, "")
                .toLocaleLowerCase();
        }
        else if (raw instanceof KeyModifier) {
            this.merge(raw, { allowOverwrite: true });
        }
        else {
            if (options?.useAccel) {
                if (Zotero.isMac) {
                    this.accel = raw.metaKey;
                }
                else {
                    this.accel = raw.ctrlKey;
                }
            }
            this.shift = raw.shiftKey;
            this.control = raw.ctrlKey;
            this.meta = raw.metaKey;
            this.alt = raw.altKey;
            if (!["Shift", "Meta", "Ctrl", "Alt", "Control"].includes(raw.key)) {
                this.key = raw.key;
            }
        }
    }
    /**
     * Merge another KeyModifier into this one.
     * @param newMod the new KeyModifier
     * @param options
     * @param options.allowOverwrite
     * @returns KeyModifier
     */
    merge(newMod, options) {
        const allowOverwrite = options?.allowOverwrite || false;
        this.mergeAttribute("accel", newMod.accel, allowOverwrite);
        this.mergeAttribute("shift", newMod.shift, allowOverwrite);
        this.mergeAttribute("control", newMod.control, allowOverwrite);
        this.mergeAttribute("meta", newMod.meta, allowOverwrite);
        this.mergeAttribute("alt", newMod.alt, allowOverwrite);
        this.mergeAttribute("key", newMod.key, allowOverwrite);
        return this;
    }
    /**
     * Check if the current KeyModifier equals to another KeyModifier.
     * @param newMod the new KeyModifier
     * @returns true if equals
     */
    equals(newMod) {
        if (typeof newMod === "string") {
            newMod = new KeyModifier(newMod);
        }
        // Compare key and non-platform modifiers first
        if (this.shift !== newMod.shift ||
            this.alt !== newMod.alt ||
            this.key.toLowerCase() !== newMod.key.toLowerCase()) {
            return false;
        }
        // Compare platform modifiers
        if (this.accel || newMod.accel) {
            if (Zotero.isMac) {
                if ((this.accel || this.meta) !== (newMod.accel || newMod.meta) ||
                    this.control !== newMod.control) {
                    return false;
                }
            }
            else {
                if ((this.accel || this.control) !== (newMod.accel || newMod.control) ||
                    this.meta !== newMod.meta) {
                    return false;
                }
            }
        }
        else {
            if (this.control !== newMod.control || this.meta !== newMod.meta) {
                return false;
            }
        }
        return true;
    }
    /**
     * Get the raw string representation of the KeyModifier.
     */
    getRaw() {
        const enabled = [];
        this.accel && enabled.push("accel");
        this.shift && enabled.push("shift");
        this.control && enabled.push("control");
        this.meta && enabled.push("meta");
        this.alt && enabled.push("alt");
        this.key && enabled.push(this.key);
        return enabled.join(",");
    }
    /**
     * Get the localized string representation of the KeyModifier.
     */
    getLocalized() {
        const raw = this.getRaw();
        if (Zotero.isMac) {
            return raw
                .replaceAll("control", "⌃")
                .replaceAll("alt", "⌥")
                .replaceAll("shift", "⇧")
                .replaceAll("meta", "⌘");
        }
        else {
            return raw
                .replaceAll("control", "Ctrl")
                .replaceAll("alt", "Alt")
                .replaceAll("shift", "Shift")
                .replaceAll("meta", "Win");
        }
    }
    /**
     * Get the un-localized string representation of the KeyModifier.
     */
    unLocalized(raw) {
        if (Zotero.isMac) {
            return raw
                .replaceAll("⌃", "control")
                .replaceAll("⌥", "alt")
                .replaceAll("⇧", "shift")
                .replaceAll("⌘", "meta");
        }
        else {
            return raw
                .replaceAll("Ctrl", "control")
                .replaceAll("Alt", "alt")
                .replaceAll("Shift", "shift")
                .replaceAll("Win", "meta");
        }
    }
    mergeAttribute(attribute, value, allowOverwrite) {
        if (allowOverwrite || !this[attribute]) {
            this[attribute] = value;
        }
    }
}
//# sourceMappingURL=keyboard.js.map
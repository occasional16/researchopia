import { loadConfig as loadConfig$1, setupDotenv } from 'c12';
import { kebabCase, mapValues, toMerged, escapeRegExp, debounce, delay } from 'es-toolkit';
import { readJsonSync, copy, move, outputFile, readJSON, outputJSON, writeJson, emptyDir, pathExists, ensureDir, remove } from 'fs-extra/esm';
import { createHooks } from 'hookable';
import { l as logger, p as parseRepoUrl, d as dateFormat, t as template, b as toArray, s as styleText, c as replaceDefine, L as LOG_LEVEL } from './zotero-plugin-scaffold.CzBjWbS8.mjs';
import process$1 from 'node:process';
import { glob, globSync } from 'tinyglobby';
import path, { resolve as resolve$1, dirname, basename, join as join$1, isAbsolute as isAbsolute$1, extname as extname$1 } from 'node:path';
import { build, context } from 'esbuild';
import { readFile, writeFile, stat } from 'node:fs/promises';
import { parse, serialize, Transformer } from '@fluent/syntax';
import fs, { existsSync, createReadStream, lstatSync, realpathSync, statSync, promises } from 'node:fs';
import { parseSync, printSync } from '@swc/core';
import { createHash } from 'node:crypto';
import AdmZip from 'adm-zip';
import { execSync, spawn } from 'node:child_process';
import { isCI, isWindows as isWindows$1, isMacOS, isLinux, isDebug } from 'std-env';
import { versionBump, ProgressEvent } from 'bumpp';
import 'node:os';
import { fileURLToPath, pathToFileURL, URL as URL$1 } from 'node:url';
import assert from 'node:assert';
import v8 from 'node:v8';
import { format, inspect } from 'node:util';
import { Octokit } from 'octokit';
import chokidar from 'chokidar';
import net from 'node:net';
import { Buffer } from 'node:buffer';
import domain from 'node:domain';
import EventEmitter from 'node:events';
import { Xvfb } from 'xvfb-ts';
import http from 'node:http';

function defineConfig(userConfig) {
  return userConfig;
}
async function loadConfig(overrides) {
  const result = await loadConfig$1({
    name: "zotero-plugin",
    dotenv: true,
    packageJson: true,
    // eslint-disable-next-line ts/no-use-before-define
    defaults: getDefaultConfig$1(),
    overrides
  });
  return resolveConfig$1(result.config);
}
function resolveConfig$1(config) {
  logger.setLogLevel(config.logLevel);
  const pkgUser = readJsonSync("package.json", {
    encoding: "utf-8"
  });
  const { name, version } = pkgUser;
  const { owner, repo } = parseRepoUrl(pkgUser.repository?.url);
  config.name ||= name;
  config.id ||= config.name;
  config.namespace ||= config.name;
  config.xpiName ||= kebabCase(config.name);
  config.build.prefs.prefix ||= pkgUser.config.prefsPrefix || `extensions.${config.namespace}`;
  const isPreRelease = version.includes("-");
  const templateData = {
    owner,
    repo,
    version,
    isPreRelease,
    updateJson: isPreRelease ? "update-beta.json" : "update.json",
    xpiName: config.xpiName,
    buildTime: dateFormat("YYYY-mm-dd HH:MM:SS", /* @__PURE__ */ new Date())
  };
  config.updateURL = template(config.updateURL, templateData);
  config.xpiDownloadLink = template(config.xpiDownloadLink, templateData);
  config.build.define = mapValues(config.build.define, (v) => template(v, templateData));
  config.release.github.repository = template(config.release.github.repository, templateData);
  const hooks = createHooks();
  hooks.addHooks(config.build.hooks);
  hooks.addHooks(config.server.hooks);
  hooks.addHooks(config.release.hooks);
  hooks.addHooks(config.test.hooks);
  const ctx = {
    ...config,
    pkgUser,
    version,
    hooks,
    logger,
    templateData
  };
  return ctx;
}
const defaultConfig = {
  source: "src",
  watchIgnore: [],
  dist: ".scaffold/build",
  name: "",
  id: "",
  namespace: "",
  xpiName: "",
  xpiDownloadLink: "https://github.com/{{owner}}/{{repo}}/releases/download/v{{version}}/{{xpiName}}.xpi",
  updateURL: "https://github.com/{{owner}}/{{repo}}/releases/download/release/{{updateJson}}",
  build: {
    assets: "addon/**/*.*",
    define: {},
    fluent: {
      prefixFluentMessages: true,
      prefixLocaleFiles: true,
      ignore: [],
      dts: "typings/i10n.d.ts"
    },
    prefs: {
      prefix: "",
      prefixPrefKeys: true,
      dts: "typings/prefs.d.ts"
    },
    esbuildOptions: [],
    makeManifest: {
      enable: true,
      template: {
        manifest_version: 2,
        name: "",
        version: "",
        applications: {
          zotero: {
            id: "",
            update_url: ""
          }
        }
      }
    },
    makeUpdateJson: {
      updates: [],
      hash: true
    },
    hooks: {}
  },
  server: {
    devtools: true,
    startArgs: [],
    asProxy: false,
    prebuild: true,
    // keepProfileChanges: true,
    createProfileIfMissing: true,
    hooks: {}
  },
  addonLint: {},
  release: {
    bumpp: {
      release: "prompt",
      preid: "beta",
      confirm: true,
      execute: "",
      all: false,
      commit: "chore(publish): release v%s",
      noVerify: false,
      tag: "v%s"
    },
    changelog: "",
    github: {
      enable: "ci",
      repository: "{{owner}}/{{repo}}",
      updater: "release",
      comment: false,
      releaseNote: (ctx) => {
        return ctx.release.changelog;
      }
    },
    hooks: {}
  },
  test: {
    entries: "test",
    prefs: {},
    mocha: {
      timeout: 1e4
    },
    abortOnFail: false,
    headless: false,
    startupDelay: 1e3,
    waitForPlugin: "() => true",
    watch: true,
    hooks: {}
  },
  logLevel: "INFO"
};
const getDefaultConfig$1 = () => defaultConfig;

class Base {
  ctx;
  constructor(ctx) {
    this.ctx = ctx;
  }
  get logger() {
    return this.ctx.logger;
  }
}

const DEFAULT_IGNORE = ["node_modules", ".git"];
async function copyAssets(source, dist, assets) {
  const sourceArr = toArray(source);
  const paths = await glob(assets, {
    ignore: [...DEFAULT_IGNORE, dist]
  });
  for (const file of paths) {
    const newPath = getNewPath(sourceArr, dist, file);
    await copy(file, newPath);
    logger.debug(`Copy ${file} to ${newPath}`);
  }
}
function getNewPath(sources, dist, path) {
  const pattern = new RegExp(sources.join("|"));
  const relativePath = path.replace(pattern, "");
  return `${dist}/addon/${relativePath}`;
}

function resolveConfig(dist, esbuildOptions) {
  const distAbsolute = resolve$1(dist);
  return esbuildOptions.map((option, i) => {
    if (option.outfile && !resolve$1(option.outfile).startsWith(distAbsolute)) {
      logger.debug(`'outfile' of esbuildOptions[${i}] is not in dist folder, it will be overwritten.`);
      option.outfile = `${dist}/${option.outfile}`;
    }
    if (option.outdir && !resolve$1(option.outdir).startsWith(distAbsolute)) {
      logger.debug(`'outdir' of esbuildOptions[${i}] is not in dist folder, it will be overwritten.`);
      option.outdir = `${dist}/${option.outdir}`;
    }
    return option;
  });
}
async function esbuild(dist, esbuildOptions) {
  if (esbuildOptions.length === 0)
    return;
  const options = resolveConfig(dist, esbuildOptions);
  return await Promise.all(
    options.map(
      (esbuildOption) => build(esbuildOption)
    )
  );
}

async function buildLocale(dist, namespace, options) {
  const ignores = toArray(options.ignore);
  const localeNames = await getLocales(dist);
  const messageManager = new MessageManager(ignores);
  await Promise.all(localeNames.map(async (locale) => {
    const paths = await glob(`${dist}/addon/locale/${locale}/**/*.ftl`);
    await Promise.all(paths.map(async (path) => {
      const fm = new FluentManager();
      await fm.read(path);
      messageManager.addMessages(locale, fm.getMessages());
      if (options.prefixFluentMessages) {
        fm.prefixMessages(namespace);
        await fm.write(path);
      }
      if (options.prefixLocaleFiles) {
        const newPath = `${dirname(path)}/${namespace}-${basename(path)}`;
        await move(path, newPath);
        logger.debug(`Renamed FTL: ${path} \u2192 ${newPath}`);
      }
    }));
  }));
  const htmlPaths = await glob([`${dist}/addon/**/*.xhtml`, `${dist}/addon/**/*.html`]);
  await Promise.all(htmlPaths.map(async (htmlPath) => {
    const content = await readFile(htmlPath, "utf-8");
    const { processedContent, foundMessages } = processHTMLFile(
      content,
      namespace,
      messageManager.getFTLMessages(),
      ignores,
      htmlPath
    );
    messageManager.addMessages("html", foundMessages);
    if (options.prefixFluentMessages) {
      await writeFile(htmlPath, processedContent);
    }
  }));
  messageManager.validateMessages();
  if (options.dts) {
    const dtsContent = generateFluentDts([...messageManager.getFTLMessages()]);
    await outputFile(options.dts, dtsContent, "utf-8");
  }
}
async function getLocales(dist) {
  const localePaths = await glob(`${dist}/addon/locale/*`, { onlyDirectories: true });
  return localePaths.map((p) => basename(p));
}
class FluentManager {
  source;
  resource;
  messages = [];
  constructor() {
  }
  // Parse Fluent source into an AST and extract messages
  parse(source) {
    this.source = source;
    this.resource = parse(source, {});
  }
  // Read a file, parse its content, and extract messages
  async read(path) {
    const content = await readFile(path, "utf-8");
    this.parse(content);
  }
  // Extract message IDs from the parsed resource
  getMessages() {
    if (!this.resource) {
      throw new Error("Resource must be parsed first.");
    }
    this.messages.length = 0;
    this.messages.push(
      ...this.resource.body.filter((entry) => entry.type === "Message").map((message) => message.id.name)
    );
    return this.messages;
  }
  // Apply namespace prefix to message IDs in the resource
  prefixMessages(namespace) {
    if (!this.resource) {
      throw new Error("Resource must be parsed before applying prefix.");
    }
    new FluentTransformer(namespace).genericVisit(this.resource);
  }
  // Serialize the resource back into a string
  serialize() {
    if (!this.resource) {
      throw new Error("Resource not parsed. Cannot serialize.");
    }
    return serialize(this.resource, {});
  }
  // Write the serialized resource to a file
  async write(path) {
    const result = this.serialize();
    if (result !== this.source)
      await writeFile(path, this.serialize());
  }
}
class FluentTransformer extends Transformer {
  constructor(prefix) {
    super();
    this.prefix = prefix;
  }
  needsPrefix(name) {
    return !!this.prefix && !name.startsWith(this.prefix);
  }
  visitMessage(node) {
    if (this.needsPrefix(node.id.name)) {
      node.id.name = `${this.prefix}-${node.id.name}`;
    }
    return this.genericVisit(node);
  }
  visitMessageReference(node) {
    if (this.needsPrefix(node.id.name)) {
      node.id.name = `${this.prefix}-${node.id.name}`;
    }
    return this.genericVisit(node);
  }
}
class MessageManager {
  ftlMessages = /* @__PURE__ */ new Map();
  htmlMessages = /* @__PURE__ */ new Set();
  ignores;
  constructor(ignores) {
    this.ignores = ignores;
  }
  // Add a set of messages (FTL or HTML) for a specific locale or for HTML globally
  addMessages(target, messages) {
    if (target === "html") {
      messages.forEach((msg) => this.htmlMessages.add(msg));
    } else {
      let ftlLocaleMessages = this.ftlMessages.get(target);
      if (!ftlLocaleMessages) {
        ftlLocaleMessages = /* @__PURE__ */ new Set();
        this.ftlMessages.set(target, ftlLocaleMessages);
      }
      messages.forEach((msg) => ftlLocaleMessages.add(msg));
    }
  }
  validateMessages() {
    this.htmlMessages.forEach((msg) => {
      if (this.ignores.includes(msg))
        return;
      const missingLocales = [...this.ftlMessages.entries()].filter(([_, messages]) => !messages.has(msg)).map(([locale]) => locale);
      if (missingLocales.length > 0)
        logger.warn(`I10N id ${styleText.blue(msg)} missing in locale: ${missingLocales.join(", ")}`);
    });
  }
  getFTLMessages() {
    const allMessages = /* @__PURE__ */ new Set();
    this.ftlMessages.forEach((messages) => messages.forEach((msg) => allMessages.add(msg)));
    return allMessages;
  }
  // Get all FTL messages for a specific locale
  getFTLMessagesByLocale(locale) {
    return this.ftlMessages.get(locale) || /* @__PURE__ */ new Set();
  }
  // Get all HTML messages
  getHTMLMessages() {
    return this.htmlMessages;
  }
}
function processHTMLFile(content, namespace, allMessages, ignores, filePath) {
  const foundMessages = /* @__PURE__ */ new Set();
  const L10N_PATTERN = new RegExp(`(data-l10n-id)="((?!${namespace})\\S*)"`, "g");
  const processed = content.replace(L10N_PATTERN, (match, attr, id) => {
    foundMessages.add(id);
    if (ignores.includes(id)) {
      logger.debug(`Skipped ignored ID: ${styleText.blue(id)} in ${styleText.gray(filePath)}`);
      return match;
    }
    if (!allMessages.has(id)) {
      logger.warn(`I10N id ${styleText.blue(id)} in path ${styleText.gray(filePath)} does not exist in any locale, skip renaming it.`);
      return match;
    }
    return `${attr}="${namespace}-${id}"`;
  });
  return { processedContent: processed, foundMessages: [...foundMessages] };
}
function generateFluentDts(messages) {
  return `// Generated by zotero-plugin-scaffold
/* prettier-ignore */
/* eslint-disable */
// @ts-nocheck
export type FluentMessageId =
${Array.from(messages).sort().map((id) => `  | '${id}'`).join("\n")};
`;
}

async function buildManifest(ctx) {
  if (!ctx.build.makeManifest.enable)
    return;
  const { name, id, updateURL, dist, version } = ctx;
  const userData = await readJSON(
    `${dist}/addon/manifest.json`
  );
  const template = {
    ...userData,
    ...!userData.name && name && { name },
    ...version && { version },
    manifest_version: 2,
    applications: {
      zotero: {
        id,
        update_url: updateURL
      }
    }
  };
  const data = toMerged(userData, template);
  logger.debug(`manifest: ${JSON.stringify(data, null, 2)}`);
  outputJSON(`${dist}/addon/manifest.json`, data, { spaces: 2 });
}

function is32BitNumber(n) {
  return Number.isInteger(n) && n >= -2147483648 && n <= 2147483647;
}

class PrefsManager {
  namespace;
  prefs = {};
  constructor(namespace) {
    this.namespace = namespace;
  }
  /**
   * Parse Method 3 - Using AST
   */
  parse(content) {
    const _map = {};
    const ast = parseSync(content, { syntax: "ecmascript" });
    for (const node of ast.body) {
      if (node.type !== "ExpressionStatement" || node.expression.type !== "CallExpression" || node.expression.callee.type !== "Identifier" || node.expression.callee.value !== this.namespace || node.expression.arguments.length !== 2) {
        throw new Error("Invalid prefs.js file.");
      }
      const [arg1, arg2] = node.expression.arguments;
      if (arg1.expression.type !== "StringLiteral") {
        throw new Error("Invalid prefs.js file - unsupported key type.");
      }
      const key = arg1.expression.value.trim();
      let value;
      switch (arg2.expression.type) {
        // https://babeljs.io/docs/babel-parser#output
        case "StringLiteral":
        case "NumericLiteral":
        case "BooleanLiteral":
          value = arg2.expression.value;
          break;
        // https://github.com/estree/estree/blob/master/es5.md#unaryexpression
        // https://github.com/northword/zotero-plugin-scaffold/issues/98
        case "UnaryExpression":
          if (arg2.expression.argument.type !== "NumericLiteral")
            throw new Error("Invalid prefs.js file - unsupported value type.");
          if (arg2.expression.operator === "-")
            value = -arg2.expression.argument.value;
          else if (arg2.expression.operator === "+")
            value = arg2.expression.argument.value;
          else
            throw new Error("Invalid prefs.js file - unsupported value type.");
          break;
        case "TemplateLiteral":
          value = arg2.expression.quasis[0]?.cooked ?? "";
          break;
        default:
          throw new Error("Invalid prefs.js file - unsupported value type.");
      }
      _map[key] = value;
    }
    return _map;
  }
  /**
   * Parse Method 1 - Using RegExp
   * @deprecated
   */
  parseByRegExp(content) {
    const _map = {};
    const prefPattern = /^(pref|user_pref)\s*\(\s*["']([^"']+)["']\s*,\s*(.+)\s*,?\s*\)\s*;?$/gm;
    const matches = content.matchAll(prefPattern);
    for (const match of matches) {
      const key = match[2].trim();
      const value = match[3].trim();
      _map[key] = this.cleanValue(value);
    }
    return _map;
  }
  /**
   * Parse Method 2 - Using eval
   * @deprecated
   */
  // private parseByEval(content: string) {
  //   const _map: Prefs = {};
  //   // eslint-disable-next-line unused-imports/no-unused-vars
  //   const pref = (key: any, value: any) => {
  //     _map[key.trim()] = this.cleanValue(value.trim());
  //   };
  //   // eslint-disable-next-line no-eval
  //   eval(content);
  //   return _map;
  // }
  cleanValue(value) {
    if (value === "true")
      return true;
    else if (value === "false")
      return false;
    else if (!Number.isNaN(Number(value)))
      return Number(value);
    else if (value.match(/^["'](.*)["']$/))
      return value.replace(/^["'](.*)["']$/, "$1");
    else
      return value;
  }
  /**
   * Render Method 2 - Using swc
   */
  render() {
    const span = { start: 0, end: 0, ctxt: 0 };
    function getExpression(value) {
      switch (typeof value) {
        case "string":
          return {
            type: "StringLiteral",
            span,
            value
          };
        case "boolean":
          return {
            type: "BooleanLiteral",
            span,
            value
          };
        case "number":
          if (value < 0) {
            return {
              type: "UnaryExpression",
              span,
              operator: "-",
              argument: {
                type: "NumericLiteral",
                span,
                value: Math.abs(value)
              }
            };
          }
          return {
            type: "NumericLiteral",
            span,
            value
          };
        default:
          throw new Error(`Unsupported value type: ${typeof value}`);
      }
    }
    const ast = {
      type: "Module",
      span,
      // @ts-expect-error no raw property
      body: Object.entries(this.prefs).map(([key, value]) => ({
        type: "ExpressionStatement",
        span,
        expression: {
          type: "CallExpression",
          span,
          ctxt: 0,
          callee: {
            type: "Identifier",
            span,
            ctxt: 0,
            value: this.namespace,
            optional: false
          },
          arguments: [
            { expression: getExpression(key) },
            { expression: getExpression(value) }
          ]
        }
      }))
    };
    const { code } = printSync(ast);
    return code;
  }
  /**
   * Render Method 1 - Using string
   * @deprecated
   */
  renderByString() {
    return Object.entries(this.prefs).map(([key, value]) => {
      const _v = typeof value === "string" ? `"${value.replaceAll("\\", "\\\\").replaceAll('"', '\\"')}"` : value;
      return `${this.namespace}("${key}", ${_v});`;
    }).join("\n");
  }
  async read(path) {
    const content = await readFile(path, "utf-8");
    const map = this.parse(content);
    this.setPrefs(map);
  }
  async write(path) {
    const content = this.render();
    await outputFile(path, content, "utf-8");
    logger.debug("The prefs.js has been modified.");
  }
  setPref(key, value) {
    if (value === null || value === void 0) {
      if (key in this.prefs)
        delete this.prefs[key];
      return;
    }
    this.prefs[key] = value;
  }
  setPrefs(prefs) {
    Object.entries(prefs).forEach(([key, value]) => {
      this.setPref(key, value);
    });
  }
  getPref(key) {
    return this.prefs[key] ?? void 0;
  }
  getPrefs() {
    return this.prefs;
  }
  clearPrefs() {
    this.prefs = {};
  }
  getPrefsWithPrefix(prefix) {
    const _prefs = {};
    for (const pref in this.prefs) {
      if (pref.startsWith(prefix))
        _prefs[pref] = this.prefs[pref];
      else
        _prefs[`${prefix}.${pref}`] = this.prefs[pref];
    }
    return _prefs;
  }
  getPrefsWithoutPrefix(prefix) {
    const _prefs = {};
    for (const pref in this.prefs) {
      _prefs[pref.replace(`${prefix}.`, "")] = this.prefs[pref];
    }
    return _prefs;
  }
}

async function buildPrefs(dist, options) {
  const { dts, prefixPrefKeys, prefix } = options;
  if (!prefixPrefKeys && !dts)
    return;
  const prefsFilePath = join$1(dist, "addon", "prefs.js");
  if (!existsSync(prefsFilePath))
    return;
  const prefsManager = new PrefsManager("pref");
  await prefsManager.read(prefsFilePath);
  const prefsWithPrefix = prefsManager.getPrefsWithPrefix(prefix);
  const prefsWithoutPrefix = prefsManager.getPrefsWithoutPrefix(prefix);
  const prefs = prefsManager.getPrefs();
  Object.entries(prefs).forEach(([key, value]) => {
    if (typeof value === "number") {
      if (!is32BitNumber(value)) {
        logger.warn(`Pref key '${styleText.blue(key)}' is a number, but is more than 4 bytes, which can be problematic on some OS.`);
      }
    }
  });
  if (dts) {
    const dtsContent = renderPluginPrefsDts(prefsWithoutPrefix);
    await outputFile(dts, dtsContent, "utf-8");
  }
  if (prefixPrefKeys) {
    prefsManager.clearPrefs();
    prefsManager.setPrefs(prefsWithPrefix);
    await prefsManager.write(prefsFilePath);
  }
  if (prefixPrefKeys) {
    const HTML_PREFERENCE_PATTERN = /preference="(\S*)"/g;
    const xhtmlPaths = await glob(`${dist}/addon/**/*.xhtml`);
    await Promise.all(xhtmlPaths.map(async (path) => {
      let content = await readFile(path, "utf-8");
      const matchs = [...content.matchAll(HTML_PREFERENCE_PATTERN)];
      for (const match of matchs) {
        const [matched, key] = match;
        if (key.startsWith(prefix)) {
          logger.debug(`Pref key '${styleText.blue(key)}' is already starts with '${prefix}', skip prefixing it.`);
          continue;
        } else if (key.startsWith("extensions.")) {
          logger.warn(`Pref key '${styleText.blue(key)}' in ${styleText.gray(path)} starts with 'extensions.' but not '${styleText.blue(prefix)}', skip prefixing it.`);
          continue;
        } else if (!(key in prefsWithPrefix) && !(key in prefsWithoutPrefix)) {
          logger.warn(`Pref key '${styleText.blue(key)}' in ${styleText.gray(path)} is not found in prefs.js, skip prefixing it.`);
          continue;
        } else {
          const prefixed = `${prefix}.${key}`;
          logger.debug(`Pref key '${styleText.blue(key)}' in ${styleText.gray(path)} is prefixed to ${styleText.blue(prefixed)}.`);
          content = content.replace(matched, `preference="${prefixed}"`);
        }
      }
      await outputFile(path, content, "utf-8");
    }));
  }
}
function renderPluginPrefsDts(prefs) {
  return `// Generated by zotero-plugin-scaffold
/* prettier-ignore */
/* eslint-disable */
// @ts-nocheck

// prettier-ignore
declare namespace _ZoteroTypes {
  interface Prefs {
    PluginPrefsMap: {
      ${Object.entries(prefs).map(([key, value]) => {
    return `"${key}": ${typeof value};`;
  }).join("\n      ")}
    };
  }
}
`;
}

function generateHash(filePath, algorithm) {
  return new Promise((resolve, reject) => {
    const hash = createHash(algorithm);
    const stream = createReadStream(filePath);
    stream.on("data", (data) => {
      hash.update(data);
    });
    stream.on("end", () => {
      const fileHash = hash.digest("hex");
      resolve(`${algorithm}:${fileHash}`);
    });
    stream.on("error", (error) => {
      reject(error);
    });
  });
}
async function buildUpdateJson(ctx) {
  const { dist, xpiName, id, version, xpiDownloadLink, build } = ctx;
  const manifest = await readJSON(
    `${dist}/addon/manifest.json`
  );
  const min = manifest.applications?.zotero?.strict_min_version;
  const max = manifest.applications?.zotero?.strict_max_version;
  const updateHash = await generateHash(`${dist}/${xpiName}.xpi`, "sha512");
  const data = {
    addons: {
      [id]: {
        updates: [
          ...build.makeUpdateJson.updates,
          {
            version,
            update_link: xpiDownloadLink,
            ...build.makeUpdateJson.hash && {
              update_hash: updateHash
            },
            applications: {
              zotero: {
                ...min && { strict_min_version: min },
                ...max && { strict_max_version: max }
              }
            }
          }
        ]
      }
    }
  };
  await writeJson(`${dist}/update-beta.json`, data, { spaces: 2 });
  if (!ctx.templateData.isPreRelease)
    await writeJson(`${dist}/update.json`, data, { spaces: 2 });
  logger.debug(
    `Prepare Update.json for ${ctx.templateData.isPreRelease ? "\x1B[31m Prerelease \x1B[0m" : "\x1B[32m Release \x1B[0m"}`
  );
}

async function pack(dist, xpiName) {
  const zip = new AdmZip();
  zip.addLocalFolder(`${dist}/addon`);
  zip.writeZip(`${dist}/${xpiName}.xpi`);
}

class Build extends Base {
  buildTime;
  constructor(ctx) {
    super(ctx);
    process$1.env.NODE_ENV ??= "production";
    this.buildTime = "";
  }
  /**
   * Default build runner
   */
  async run() {
    const { dist, version } = this.ctx;
    const t = /* @__PURE__ */ new Date();
    this.buildTime = dateFormat("YYYY-mm-dd HH:MM:SS", t);
    this.logger.info(`Building version ${styleText.blue(version)} to ${styleText.blue(dist)} at ${styleText.blue(this.buildTime)} in ${styleText.blue(process$1.env.NODE_ENV)} mode.`);
    await this.ctx.hooks.callHook("build:init", this.ctx);
    this.logger.tip("Preparing static assets", { space: 1 });
    await this.prepareAssets();
    this.logger.tip("Bundling scripts", { space: 1 });
    await this.bundle();
    if (process$1.env.NODE_ENV === "production") {
      this.logger.tip("Packing plugin", { space: 1 });
      this.buildInProduction();
    }
    await this.ctx.hooks.callHook("build:done", this.ctx);
    this.logger.success(`Build finished in ${((/* @__PURE__ */ new Date()).getTime() - t.getTime()) / 1e3} s.`);
  }
  async prepareAssets() {
    const { source, namespace, dist, build } = this.ctx;
    await emptyDir(dist);
    await this.ctx.hooks.callHook("build:mkdir", this.ctx);
    await copyAssets(source, dist, build.assets);
    await replaceDefine(dist, build.define);
    await this.ctx.hooks.callHook("build:copyAssets", this.ctx);
    this.logger.debug("Preparing manifest", { space: 2 });
    await buildManifest(this.ctx);
    await this.ctx.hooks.callHook("build:makeManifest", this.ctx);
    this.logger.debug("Preparing locale files", { space: 2 });
    await buildLocale(dist, namespace, build.fluent);
    await this.ctx.hooks.callHook("build:fluent", this.ctx);
    this.logger.debug("Preparing preference files", { space: 2 });
    await buildPrefs(dist, build.prefs);
  }
  async bundle() {
    const { dist, build: { esbuildOptions } } = this.ctx;
    await esbuild(dist, esbuildOptions);
    await this.ctx.hooks.callHook("build:bundle", this.ctx);
  }
  async buildInProduction() {
    const { dist, xpiName } = this.ctx;
    await pack(dist, xpiName);
    await this.ctx.hooks.callHook("build:pack", this.ctx);
    await buildUpdateJson(this.ctx);
    await this.ctx.hooks.callHook("build:makeUpdateJSON", this.ctx);
  }
  exit() {
  }
}

class ReleaseBase {
  isCI;
  ctx;
  constructor(ctx) {
    this.ctx = ctx;
    this.isCI = isCI;
  }
  checkFiles() {
    const { dist } = this.ctx;
    if (globSync(`${dist}/*.xpi`).length === 0) {
      throw new Error("No xpi file found, are you sure you have run build?");
    }
  }
  get logger() {
    return this.ctx.logger;
  }
}

class Bump extends ReleaseBase {
  constructor(ctx) {
    super(ctx);
  }
  async run() {
    const bumppConfig = {
      ...this.ctx.release.bumpp,
      push: true,
      progress: this.bumppProgress
    };
    const { version } = this.ctx;
    if (bumppConfig.release === version) {
      this.logger.debug("Commit, tag, and push are disabled because new version = old version.");
      bumppConfig.commit = false;
      bumppConfig.tag = false;
      bumppConfig.push = false;
    }
    const result = await versionBump(bumppConfig);
    this.ctx.version = result.newVersion;
    this.ctx.release.bumpp.tag = result.tag || this.ctx.release.bumpp.tag.toString().replace("%s", result.newVersion);
    this.ctx.release.bumpp.commit = result.commit || this.ctx.release.bumpp.commit.toString().replace("%s", result.newVersion);
    this.logger.debug(`The release context after bump: ", ${this.ctx.release}`);
  }
  /**
   * bumpp 显示进度的回调
   *
   * @see https://github.com/antfu/bumpp/blob/main/src/cli/index.ts
   */
  get bumppProgress() {
    return ({
      event,
      script,
      updatedFiles,
      skippedFiles,
      newVersion
    }) => {
      switch (event) {
        case ProgressEvent.FileUpdated:
          this.logger.success(`Updated ${updatedFiles.pop()} to ${newVersion}`);
          break;
        case ProgressEvent.FileSkipped:
          this.logger.info(`${skippedFiles.pop()} did not need to be updated`);
          break;
        case ProgressEvent.GitCommit:
          this.logger.success("Git commit");
          break;
        case ProgressEvent.GitTag:
          this.logger.success("Git tag");
          break;
        case ProgressEvent.GitPush:
          this.logger.success("Git push");
          break;
        case ProgressEvent.NpmScript:
          this.logger.success(`Npm run ${script}`);
          break;
      }
    };
  }
}

const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}

const _UNC_REGEX = /^[/\\]{2}/;
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
const normalize = function(path) {
  if (path.length === 0) {
    return ".";
  }
  path = normalizeWindowsPath(path);
  const isUNCPath = path.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path);
  const trailingSeparator = path[path.length - 1] === "/";
  path = normalizeString(path, !isPathAbsolute);
  if (path.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path += "/";
  }
  if (_DRIVE_LETTER_RE.test(path)) {
    path += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path}`;
    }
    return `//${path}`;
  }
  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
};
const join = function(...segments) {
  let path = "";
  for (const seg of segments) {
    if (!seg) {
      continue;
    }
    if (path.length > 0) {
      const pathTrailing = path[path.length - 1] === "/";
      const segLeading = seg[0] === "/";
      const both = pathTrailing && segLeading;
      if (both) {
        path += seg.slice(1);
      } else {
        path += pathTrailing || segLeading ? seg : `/${seg}`;
      }
    } else {
      path += seg;
    }
  }
  return normalize(path);
};
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};

function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}

const gitmojis = {
  ":art:": "\u{1F3A8}",
  ":zap:": "\u26A1\uFE0F",
  ":fire:": "\u{1F525}",
  ":bug:": "\u{1F41B}",
  ":ambulance:": "\u{1F691}\uFE0F",
  ":sparkles:": "\u2728",
  ":memo:": "\u{1F4DD}",
  ":rocket:": "\u{1F680}",
  ":lipstick:": "\u{1F484}",
  ":tada:": "\u{1F389}",
  ":white_check_mark:": "\u2705",
  ":lock:": "\u{1F512}\uFE0F",
  ":closed_lock_with_key:": "\u{1F510}",
  ":bookmark:": "\u{1F516}",
  ":rotating_light:": "\u{1F6A8}",
  ":construction:": "\u{1F6A7}",
  ":green_heart:": "\u{1F49A}",
  ":arrow_down:": "\u2B07\uFE0F",
  ":arrow_up:": "\u2B06\uFE0F",
  ":pushpin:": "\u{1F4CC}",
  ":construction_worker:": "\u{1F477}",
  ":chart_with_upwards_trend:": "\u{1F4C8}",
  ":recycle:": "\u267B\uFE0F",
  ":heavy_plus_sign:": "\u2795",
  ":heavy_minus_sign:": "\u2796",
  ":wrench:": "\u{1F527}",
  ":hammer:": "\u{1F528}",
  ":globe_with_meridians:": "\u{1F310}",
  ":pencil2:": "\u270F\uFE0F",
  ":pencil:": "\u270F\uFE0F",
  ":poop:": "\u{1F4A9}",
  ":rewind:": "\u23EA\uFE0F",
  ":twisted_rightwards_arrows:": "\u{1F500}",
  ":package:": "\u{1F4E6}\uFE0F",
  ":alien:": "\u{1F47D}\uFE0F",
  ":truck:": "\u{1F69A}",
  ":page_facing_up:": "\u{1F4C4}",
  ":boom:": "\u{1F4A5}",
  ":bento:": "\u{1F371}",
  ":wheelchair:": "\u267F\uFE0F",
  ":bulb:": "\u{1F4A1}",
  ":beers:": "\u{1F37B}",
  ":speech_balloon:": "\u{1F4AC}",
  ":card_file_box:": "\u{1F5C3}\uFE0F",
  ":loud_sound:": "\u{1F50A}",
  ":mute:": "\u{1F507}",
  ":busts_in_silhouette:": "\u{1F465}",
  ":children_crossing:": "\u{1F6B8}",
  ":building_construction:": "\u{1F3D7}\uFE0F",
  ":iphone:": "\u{1F4F1}",
  ":clown_face:": "\u{1F921}",
  ":egg:": "\u{1F95A}",
  ":see_no_evil:": "\u{1F648}",
  ":camera_flash:": "\u{1F4F8}",
  ":alembic:": "\u2697\uFE0F",
  ":mag:": "\u{1F50D}\uFE0F",
  ":label:": "\u{1F3F7}\uFE0F",
  ":seedling:": "\u{1F331}",
  ":triangular_flag_on_post:": "\u{1F6A9}",
  ":goal_net:": "\u{1F945}",
  ":dizzy:": "\u{1F4AB}",
  ":wastebasket:": "\u{1F5D1}\uFE0F",
  ":passport_control:": "\u{1F6C2}",
  ":adhesive_bandage:": "\u{1FA79}",
  ":monocle_face:": "\u{1F9D0}",
  ":coffin:": "\u26B0\uFE0F",
  ":test_tube:": "\u{1F9EA}",
  ":necktie:": "\u{1F454}",
  ":stethoscope:": "\u{1FA7A}",
  ":bricks:": "\u{1F9F1}",
  ":technologist:": "\u{1F9D1}\u200D\u{1F4BB}",
  ":money_with_wings:": "\u{1F4B8}",
  ":thread:": "\u{1F9F5}",
  ":safety_vest:": "\u{1F9BA}"
};
function convert(content, withSpace) {
  const re = new RegExp(Object.keys(gitmojis).join("|"), "gi");
  return content.replace(re, function(matched) {
    switch (withSpace) {
      case true:
      case "trailing":
        return `${gitmojis[matched.toLowerCase()]} `;
      case "leading":
        return ` ${gitmojis[matched.toLowerCase()]}`;
      case "both":
        return ` ${gitmojis[matched.toLowerCase()]} `;
      default:
        return gitmojis[matched.toLowerCase()];
    }
  });
}

const l=globalThis.fetch||(()=>{throw new Error("[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!")});

const m=Symbol.for("__confbox_fmt__"),k=/^(\s+)/,v=/(\s+)$/;function x$1(e,t={}){const n=t.indent===void 0&&t.preserveIndentation!==false&&e.slice(0,t?.sampleSize||1024),s=t.preserveWhitespace===false?void 0:{start:k.exec(e)?.[0]||"",end:v.exec(e)?.[0]||""};return {sample:n,whiteSpace:s}}function N$1(e,t,n){!t||typeof t!="object"||Object.defineProperty(t,m,{enumerable:false,configurable:true,writable:true,value:x$1(e,n)});}

function $(n,l=false){const g=n.length;let e=0,u="",p=0,k=16,A=0,o=0,O=0,B=0,b=0;function I(i,T){let s=0,c=0;for(;s<i;){let t=n.charCodeAt(e);if(t>=48&&t<=57)c=c*16+t-48;else if(t>=65&&t<=70)c=c*16+t-65+10;else if(t>=97&&t<=102)c=c*16+t-97+10;else break;e++,s++;}return s<i&&(c=-1),c}function V(i){e=i,u="",p=0,k=16,b=0;}function F(){let i=e;if(n.charCodeAt(e)===48)e++;else for(e++;e<n.length&&L(n.charCodeAt(e));)e++;if(e<n.length&&n.charCodeAt(e)===46)if(e++,e<n.length&&L(n.charCodeAt(e)))for(e++;e<n.length&&L(n.charCodeAt(e));)e++;else return b=3,n.substring(i,e);let T=e;if(e<n.length&&(n.charCodeAt(e)===69||n.charCodeAt(e)===101))if(e++,(e<n.length&&n.charCodeAt(e)===43||n.charCodeAt(e)===45)&&e++,e<n.length&&L(n.charCodeAt(e))){for(e++;e<n.length&&L(n.charCodeAt(e));)e++;T=e;}else b=3;return n.substring(i,T)}function a(){let i="",T=e;for(;;){if(e>=g){i+=n.substring(T,e),b=2;break}const s=n.charCodeAt(e);if(s===34){i+=n.substring(T,e),e++;break}if(s===92){if(i+=n.substring(T,e),e++,e>=g){b=2;break}switch(n.charCodeAt(e++)){case 34:i+='"';break;case 92:i+="\\";break;case 47:i+="/";break;case 98:i+="\b";break;case 102:i+="\f";break;case 110:i+=`
`;break;case 114:i+="\r";break;case 116:i+="	";break;case 117:const t=I(4);t>=0?i+=String.fromCharCode(t):b=4;break;default:b=5;}T=e;continue}if(s>=0&&s<=31)if(r(s)){i+=n.substring(T,e),b=2;break}else b=6;e++;}return i}function w(){if(u="",b=0,p=e,o=A,B=O,e>=g)return p=g,k=17;let i=n.charCodeAt(e);if(J(i)){do e++,u+=String.fromCharCode(i),i=n.charCodeAt(e);while(J(i));return k=15}if(r(i))return e++,u+=String.fromCharCode(i),i===13&&n.charCodeAt(e)===10&&(e++,u+=`
`),A++,O=e,k=14;switch(i){case 123:return e++,k=1;case 125:return e++,k=2;case 91:return e++,k=3;case 93:return e++,k=4;case 58:return e++,k=6;case 44:return e++,k=5;case 34:return e++,u=a(),k=10;case 47:const T=e-1;if(n.charCodeAt(e+1)===47){for(e+=2;e<g&&!r(n.charCodeAt(e));)e++;return u=n.substring(T,e),k=12}if(n.charCodeAt(e+1)===42){e+=2;const s=g-1;let c=false;for(;e<s;){const t=n.charCodeAt(e);if(t===42&&n.charCodeAt(e+1)===47){e+=2,c=true;break}e++,r(t)&&(t===13&&n.charCodeAt(e)===10&&e++,A++,O=e);}return c||(e++,b=1),u=n.substring(T,e),k=13}return u+=String.fromCharCode(i),e++,k=16;case 45:if(u+=String.fromCharCode(i),e++,e===g||!L(n.charCodeAt(e)))return k=16;case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return u+=F(),k=11;default:for(;e<g&&v(i);)e++,i=n.charCodeAt(e);if(p!==e){switch(u=n.substring(p,e),u){case "true":return k=8;case "false":return k=9;case "null":return k=7}return k=16}return u+=String.fromCharCode(i),e++,k=16}}function v(i){if(J(i)||r(i))return  false;switch(i){case 125:case 93:case 123:case 91:case 34:case 58:case 44:case 47:return  false}return  true}function j(){let i;do i=w();while(i>=12&&i<=15);return i}return {setPosition:V,getPosition:()=>e,scan:l?j:w,getToken:()=>k,getTokenValue:()=>u,getTokenOffset:()=>p,getTokenLength:()=>e-p,getTokenStartLine:()=>o,getTokenStartCharacter:()=>p-B,getTokenError:()=>b}}function J(n){return n===32||n===9}function r(n){return n===10||n===13}function L(n){return n>=48&&n<=57}var Q;((function(n){n[n.lineFeed=10]="lineFeed",n[n.carriageReturn=13]="carriageReturn",n[n.space=32]="space",n[n._0=48]="_0",n[n._1=49]="_1",n[n._2=50]="_2",n[n._3=51]="_3",n[n._4=52]="_4",n[n._5=53]="_5",n[n._6=54]="_6",n[n._7=55]="_7",n[n._8=56]="_8",n[n._9=57]="_9",n[n.a=97]="a",n[n.b=98]="b",n[n.c=99]="c",n[n.d=100]="d",n[n.e=101]="e",n[n.f=102]="f",n[n.g=103]="g",n[n.h=104]="h",n[n.i=105]="i",n[n.j=106]="j",n[n.k=107]="k",n[n.l=108]="l",n[n.m=109]="m",n[n.n=110]="n",n[n.o=111]="o",n[n.p=112]="p",n[n.q=113]="q",n[n.r=114]="r",n[n.s=115]="s",n[n.t=116]="t",n[n.u=117]="u",n[n.v=118]="v",n[n.w=119]="w",n[n.x=120]="x",n[n.y=121]="y",n[n.z=122]="z",n[n.A=65]="A",n[n.B=66]="B",n[n.C=67]="C",n[n.D=68]="D",n[n.E=69]="E",n[n.F=70]="F",n[n.G=71]="G",n[n.H=72]="H",n[n.I=73]="I",n[n.J=74]="J",n[n.K=75]="K",n[n.L=76]="L",n[n.M=77]="M",n[n.N=78]="N",n[n.O=79]="O",n[n.P=80]="P",n[n.Q=81]="Q",n[n.R=82]="R",n[n.S=83]="S",n[n.T=84]="T",n[n.U=85]="U",n[n.V=86]="V",n[n.W=87]="W",n[n.X=88]="X",n[n.Y=89]="Y",n[n.Z=90]="Z",n[n.asterisk=42]="asterisk",n[n.backslash=92]="backslash",n[n.closeBrace=125]="closeBrace",n[n.closeBracket=93]="closeBracket",n[n.colon=58]="colon",n[n.comma=44]="comma",n[n.dot=46]="dot",n[n.doubleQuote=34]="doubleQuote",n[n.minus=45]="minus",n[n.openBrace=123]="openBrace",n[n.openBracket=91]="openBracket",n[n.plus=43]="plus",n[n.slash=47]="slash",n[n.formFeed=12]="formFeed",n[n.tab=9]="tab";}))(Q||(Q={})),new Array(20).fill(0).map((n,l)=>" ".repeat(l));const N=200;new Array(N).fill(0).map((n,l)=>`
`+" ".repeat(l)),new Array(N).fill(0).map((n,l)=>"\r"+" ".repeat(l)),new Array(N).fill(0).map((n,l)=>`\r
`+" ".repeat(l)),new Array(N).fill(0).map((n,l)=>`
`+"	".repeat(l)),new Array(N).fill(0).map((n,l)=>"\r"+"	".repeat(l)),new Array(N).fill(0).map((n,l)=>`\r
`+"	".repeat(l));var U;(function(n){n.DEFAULT={allowTrailingComma:false};})(U||(U={}));function S(n,l=[],g=U.DEFAULT){let e=null,u=[];const p=[];function k(o){Array.isArray(u)?u.push(o):e!==null&&(u[e]=o);}return P(n,{onObjectBegin:()=>{const o={};k(o),p.push(u),u=o,e=null;},onObjectProperty:o=>{e=o;},onObjectEnd:()=>{u=p.pop();},onArrayBegin:()=>{const o=[];k(o),p.push(u),u=o,e=null;},onArrayEnd:()=>{u=p.pop();},onLiteralValue:k,onError:(o,O,B)=>{l.push({error:o,offset:O,length:B});}},g),u[0]}function P(n,l,g=U.DEFAULT){const e=$(n,false),u=[];let p=0;function k(f){return f?()=>p===0&&f(e.getTokenOffset(),e.getTokenLength(),e.getTokenStartLine(),e.getTokenStartCharacter()):()=>true}function A(f){return f?m=>p===0&&f(m,e.getTokenOffset(),e.getTokenLength(),e.getTokenStartLine(),e.getTokenStartCharacter()):()=>true}function o(f){return f?m=>p===0&&f(m,e.getTokenOffset(),e.getTokenLength(),e.getTokenStartLine(),e.getTokenStartCharacter(),()=>u.slice()):()=>true}function O(f){return f?()=>{p>0?p++:f(e.getTokenOffset(),e.getTokenLength(),e.getTokenStartLine(),e.getTokenStartCharacter(),()=>u.slice())===false&&(p=1);}:()=>true}function B(f){return f?()=>{p>0&&p--,p===0&&f(e.getTokenOffset(),e.getTokenLength(),e.getTokenStartLine(),e.getTokenStartCharacter());}:()=>true}const b=O(l.onObjectBegin),I=o(l.onObjectProperty),V=B(l.onObjectEnd),F=O(l.onArrayBegin),a=B(l.onArrayEnd),w=o(l.onLiteralValue),v=A(l.onSeparator),j=k(l.onComment),i=A(l.onError),T=g&&g.disallowComments,s=g&&g.allowTrailingComma;function c(){for(;;){const f=e.scan();switch(e.getTokenError()){case 4:t(14);break;case 5:t(15);break;case 3:t(13);break;case 1:T||t(11);break;case 2:t(12);break;case 6:t(16);break}switch(f){case 12:case 13:T?t(10):j();break;case 16:t(1);break;case 15:case 14:break;default:return f}}}function t(f,m=[],y=[]){if(i(f),m.length+y.length>0){let _=e.getToken();for(;_!==17;){if(m.indexOf(_)!==-1){c();break}else if(y.indexOf(_)!==-1)break;_=c();}}}function D(f){const m=e.getTokenValue();return f?w(m):(I(m),u.push(m)),c(),true}function G(){switch(e.getToken()){case 11:const f=e.getTokenValue();let m=Number(f);isNaN(m)&&(t(2),m=0),w(m);break;case 7:w(null);break;case 8:w(true);break;case 9:w(false);break;default:return  false}return c(),true}function M(){return e.getToken()!==10?(t(3,[],[2,5]),false):(D(false),e.getToken()===6?(v(":"),c(),E()||t(4,[],[2,5])):t(5,[],[2,5]),u.pop(),true)}function X(){b(),c();let f=false;for(;e.getToken()!==2&&e.getToken()!==17;){if(e.getToken()===5){if(f||t(4,[],[]),v(","),c(),e.getToken()===2&&s)break}else f&&t(6,[],[]);M()||t(4,[],[2,5]),f=true;}return V(),e.getToken()!==2?t(7,[2],[]):c(),true}function Y(){F(),c();let f=true,m=false;for(;e.getToken()!==4&&e.getToken()!==17;){if(e.getToken()===5){if(m||t(4,[],[]),v(","),c(),e.getToken()===4&&s)break}else m&&t(6,[],[]);f?(u.push(0),f=false):u[u.length-1]++,E()||t(4,[],[4,5]),m=true;}return a(),f||u.pop(),e.getToken()!==4?t(8,[4],[]):c(),true}function E(){switch(e.getToken()){case 3:return Y();case 1:return X();case 10:return D(true);default:return G()}}return c(),e.getToken()===17?g.allowEmptyContent?true:(t(4,[],[]),false):E()?(e.getToken()!==17&&t(9,[],[]),true):(t(4,[],[]),false)}var W;(function(n){n[n.None=0]="None",n[n.UnexpectedEndOfComment=1]="UnexpectedEndOfComment",n[n.UnexpectedEndOfString=2]="UnexpectedEndOfString",n[n.UnexpectedEndOfNumber=3]="UnexpectedEndOfNumber",n[n.InvalidUnicode=4]="InvalidUnicode",n[n.InvalidEscapeCharacter=5]="InvalidEscapeCharacter",n[n.InvalidCharacter=6]="InvalidCharacter";})(W||(W={}));var H;(function(n){n[n.OpenBraceToken=1]="OpenBraceToken",n[n.CloseBraceToken=2]="CloseBraceToken",n[n.OpenBracketToken=3]="OpenBracketToken",n[n.CloseBracketToken=4]="CloseBracketToken",n[n.CommaToken=5]="CommaToken",n[n.ColonToken=6]="ColonToken",n[n.NullKeyword=7]="NullKeyword",n[n.TrueKeyword=8]="TrueKeyword",n[n.FalseKeyword=9]="FalseKeyword",n[n.StringLiteral=10]="StringLiteral",n[n.NumericLiteral=11]="NumericLiteral",n[n.LineCommentTrivia=12]="LineCommentTrivia",n[n.BlockCommentTrivia=13]="BlockCommentTrivia",n[n.LineBreakTrivia=14]="LineBreakTrivia",n[n.Trivia=15]="Trivia",n[n.Unknown=16]="Unknown",n[n.EOF=17]="EOF";})(H||(H={}));const K=S;var q;(function(n){n[n.InvalidSymbol=1]="InvalidSymbol",n[n.InvalidNumberFormat=2]="InvalidNumberFormat",n[n.PropertyNameExpected=3]="PropertyNameExpected",n[n.ValueExpected=4]="ValueExpected",n[n.ColonExpected=5]="ColonExpected",n[n.CommaExpected=6]="CommaExpected",n[n.CloseBraceExpected=7]="CloseBraceExpected",n[n.CloseBracketExpected=8]="CloseBracketExpected",n[n.EndOfFileExpected=9]="EndOfFileExpected",n[n.InvalidCommentToken=10]="InvalidCommentToken",n[n.UnexpectedEndOfComment=11]="UnexpectedEndOfComment",n[n.UnexpectedEndOfString=12]="UnexpectedEndOfString",n[n.UnexpectedEndOfNumber=13]="UnexpectedEndOfNumber",n[n.InvalidUnicode=14]="InvalidUnicode",n[n.InvalidEscapeCharacter=15]="InvalidEscapeCharacter",n[n.InvalidCharacter=16]="InvalidCharacter";})(q||(q={}));function x(n,l){const g=JSON.parse(n,l?.reviver);return N$1(n,g,l),g}function h(n,l){const g=K(n,l?.errors,l);return N$1(n,g,l),g}

const nodeBuiltins = [
  "_http_agent",
  "_http_client",
  "_http_common",
  "_http_incoming",
  "_http_outgoing",
  "_http_server",
  "_stream_duplex",
  "_stream_passthrough",
  "_stream_readable",
  "_stream_transform",
  "_stream_wrap",
  "_stream_writable",
  "_tls_common",
  "_tls_wrap",
  "assert",
  "assert/strict",
  "async_hooks",
  "buffer",
  "child_process",
  "cluster",
  "console",
  "constants",
  "crypto",
  "dgram",
  "diagnostics_channel",
  "dns",
  "dns/promises",
  "domain",
  "events",
  "fs",
  "fs/promises",
  "http",
  "http2",
  "https",
  "inspector",
  "inspector/promises",
  "module",
  "net",
  "os",
  "path",
  "path/posix",
  "path/win32",
  "perf_hooks",
  "process",
  "punycode",
  "querystring",
  "readline",
  "readline/promises",
  "repl",
  "stream",
  "stream/consumers",
  "stream/promises",
  "stream/web",
  "string_decoder",
  "sys",
  "timers",
  "timers/promises",
  "tls",
  "trace_events",
  "tty",
  "url",
  "util",
  "util/types",
  "v8",
  "vm",
  "wasi",
  "worker_threads",
  "zlib"
];

const own$1 = {}.hasOwnProperty;
const classRegExp = /^([A-Z][a-z\d]*)+$/;
const kTypes = /* @__PURE__ */ new Set([
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]);
const messages = /* @__PURE__ */ new Map();
const nodeInternalPrefix = "__node_internal_";
let userStackTraceLimit;
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array.at(-1)}`;
}
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  };
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
const captureLargerStackTrace = hideStackFrames(function(error) {
  const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  if (stackTraceLimitIsWritable) {
    userStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
  }
  Error.captureStackTrace(error);
  if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
  return error;
});
function getMessage(key, parameters, self) {
  const message = messages.get(key);
  assert(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    assert(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  assert(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(format, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === void 0) {
    return String(value);
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${inspect(value, { depth: -1 })}`;
  }
  let inspected = inspect(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}
createError(
  "ERR_INVALID_ARG_TYPE",
  (name, expected, actual) => {
    assert(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let message = "The ";
    if (name.endsWith(" argument")) {
      message += `${name} `;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      message += `"${name}" ${type} `;
    }
    message += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      assert(
        typeof value === "string",
        "All expected entries have to be of type string"
      );
      if (kTypes.has(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.exec(value) === null) {
        assert(
          value !== "object",
          'The value "object" should be written as "Object"'
        );
        other.push(value);
      } else {
        instances.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.slice(pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(
        types,
        "or"
      )}`;
      if (instances.length > 0 || other.length > 0) message += " or ";
    }
    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, "or")}`;
      if (other.length > 0) message += " or ";
    }
    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, "or")}`;
      } else {
        if (other[0]?.toLowerCase() !== other[0]) message += "an ";
        message += `${other[0]}`;
      }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
  },
  TypeError
);
const ERR_INVALID_MODULE_SPECIFIER = createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
  },
  TypeError
);
const ERR_INVALID_PACKAGE_CONFIG = createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  (path, base, message) => {
    return `Invalid package config ${path}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
const ERR_INVALID_PACKAGE_TARGET = createError(
  "ERR_INVALID_PACKAGE_TARGET",
  (packagePath, key, target, isImport = false, base) => {
    const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      assert(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
const ERR_MODULE_NOT_FOUND = createError(
  "ERR_MODULE_NOT_FOUND",
  (path, base, exactUrl = false) => {
    return `Cannot find ${exactUrl ? "module" : "package"} '${path}' imported from ${base}`;
  },
  Error
);
createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
const ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath || ""}package.json` : ""} imported from ${base}`;
  },
  TypeError
);
const ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} packagePath
   * @param {string} subpath
   * @param {string} [base]
   */
  (packagePath, subpath, base) => {
    if (subpath === ".")
      return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);
const ERR_UNSUPPORTED_DIR_IMPORT = createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
const ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
  "ERR_UNSUPPORTED_RESOLVE_REQUEST",
  'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
  TypeError
);
const ERR_UNKNOWN_FILE_EXTENSION = createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  (extension, path) => {
    return `Unknown file extension "${extension}" for ${path}`;
  },
  TypeError
);
createError(
  "ERR_INVALID_ARG_VALUE",
  (name, value, reason = "is invalid") => {
    let inspected = inspect(value);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);

const hasOwnProperty$1 = {}.hasOwnProperty;
const cache = /* @__PURE__ */ new Map();
function read(jsonPath, { base, specifier }) {
  const existing = cache.get(jsonPath);
  if (existing) {
    return existing;
  }
  let string;
  try {
    string = fs.readFileSync(path.toNamespacedPath(jsonPath), "utf8");
  } catch (error) {
    const exception = error;
    if (exception.code !== "ENOENT") {
      throw exception;
    }
  }
  const result = {
    exists: false,
    pjsonPath: jsonPath,
    main: void 0,
    name: void 0,
    type: "none",
    // Ignore unknown types for forwards compatibility
    exports: void 0,
    imports: void 0
  };
  if (string !== void 0) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      const error = new ERR_INVALID_PACKAGE_CONFIG(
        jsonPath,
        (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier),
        error_.message
      );
      error.cause = error_;
      throw error;
    }
    result.exists = true;
    if (hasOwnProperty$1.call(parsed, "name") && typeof parsed.name === "string") {
      result.name = parsed.name;
    }
    if (hasOwnProperty$1.call(parsed, "main") && typeof parsed.main === "string") {
      result.main = parsed.main;
    }
    if (hasOwnProperty$1.call(parsed, "exports")) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty$1.call(parsed, "imports")) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
      result.type = parsed.type;
    }
  }
  cache.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL("package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (packageJSONPath2.endsWith("node_modules/package.json")) {
      break;
    }
    const packageConfig = read(fileURLToPath(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = fileURLToPath(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: "none"
  };
}

const hasOwnProperty = {}.hasOwnProperty;
const extensionFormatMap = {
  __proto__: null,
  ".json": "json",
  ".cjs": "commonjs",
  ".cts": "commonjs",
  ".js": "module",
  ".ts": "module",
  ".mts": "module",
  ".mjs": "module"
};
const protocolHandlers = {
  __proto__: null,
  "data:": getDataProtocolModuleFormat,
  "file:": getFileProtocolModuleFormat,
  "node:": () => "builtin"
};
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json") return "json";
  return null;
}
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url) {
  const pathname = url.pathname;
  let index = pathname.length;
  while (index--) {
    const code = pathname.codePointAt(index);
    if (code === 47) {
      return "";
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
    }
  }
  return "";
}
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
  const ext = extname(url);
  if (ext === ".js") {
    const { type: packageType } = getPackageScopeConfig(url);
    if (packageType !== "none") {
      return packageType;
    }
    return "commonjs";
  }
  if (ext === "") {
    const { type: packageType } = getPackageScopeConfig(url);
    if (packageType === "none" || packageType === "commonjs") {
      return "commonjs";
    }
    return "module";
  }
  const format = extensionFormatMap[ext];
  if (format) return format;
  if (ignoreErrors) {
    return void 0;
  }
  const filepath = fileURLToPath(url);
  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);
}
function defaultGetFormatWithoutErrors(url, context) {
  const protocol = url.protocol;
  if (!hasOwnProperty.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url, context, true) || null;
}

const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
const own = {}.hasOwnProperty;
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
const deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const invalidPackageNameRegEx = /^\.|%|\\/;
const patternRegEx = /\*/g;
const encodedSeparatorRegEx = /%2f|%5c/i;
const emittedPackageWarnings = /* @__PURE__ */ new Set();
const doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  if (process$1.noDeprecation) {
    return;
  }
  const pjsonPath = fileURLToPath(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  process$1.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  if (process$1.noDeprecation) {
    return;
  }
  const format = defaultGetFormatWithoutErrors(url, { parentURL: base.href });
  if (format !== "module") return;
  const urlPath = fileURLToPath(url.href);
  const packagePath = fileURLToPath(new URL$1(".", packageJsonUrl));
  const basePath = fileURLToPath(base);
  if (!main) {
    process$1.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  } else if (path.resolve(packagePath, main) !== urlPath) {
    process$1.emitWarning(
      `Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  }
}
function tryStatSync(path2) {
  try {
    return statSync(path2);
  } catch {
  }
}
function fileExists(url) {
  const stats = statSync(url, { throwIfNoEntry: false });
  const isFile = stats ? stats.isFile() : void 0;
  return isFile === null || isFile === void 0 ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new URL$1(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new URL$1(tries2[i2], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new URL$1(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    fileURLToPath(new URL$1(".", packageJsonUrl)),
    fileURLToPath(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      String.raw`must not include encoded "/" or "\" characters`,
      fileURLToPath(base)
    );
  }
  let filePath;
  try {
    filePath = fileURLToPath(resolved);
  } catch (error) {
    Object.defineProperty(error, "input", { value: String(resolved) });
    Object.defineProperty(error, "module", { value: String(base) });
    throw error;
  }
  const stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats && stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats || !stats.isFile()) {
    const error = new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && fileURLToPath(base),
      true
    );
    error.url = String(resolved);
    throw error;
  }
  {
    const real = realpathSync(filePath);
    const { search, hash } = resolved;
    resolved = pathToFileURL(real + (filePath.endsWith(path.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && fileURLToPath(new URL$1(".", packageJsonUrl)),
    fileURLToPath(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    fileURLToPath(new URL$1(".", packageJsonUrl)),
    subpath,
    base && fileURLToPath(base)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && fileURLToPath(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    fileURLToPath(new URL$1(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && fileURLToPath(base)
  );
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target.at(-1) !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL = false;
      try {
        new URL$1(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new URL$1(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL$1(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === "") return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new URL$1(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new URL$1(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key) return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error) {
        const exception = error;
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
        throw error;
      }
      if (resolveResult === void 0) continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys.length) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          fileURLToPath(packageJsonUrl),
          fileURLToPath(base),
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i = -1;
    while (++i < keys.length) {
      const key = keys[i];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === "string" || Array.isArray(exports)) return true;
  if (typeof exports !== "object" || exports === null) return false;
  const keys = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  let keyIndex = -1;
  while (++keyIndex < keys.length) {
    const key = keys[keyIndex];
    const currentIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG(
        fileURLToPath(packageJsonUrl),
        fileURLToPath(base),
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  if (process$1.noDeprecation) {
    return;
  }
  const pjsonPath = fileURLToPath(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match)) return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  process$1.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
    exports = { ".": exports };
  }
  if (own.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys = Object.getOwnPropertyNames(exports);
  let i = -1;
  while (++i < keys.length) {
    const key = keys[i];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base
        );
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = exports[bestMatch];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB) return -1;
  if (baseLengthB > baseLengthA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length > b.length) return -1;
  if (b.length > a.length) return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys.length) {
          const key = keys[i];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      fileURLToPath(base)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (nodeBuiltins.includes(specifier)) {
    return new URL$1("node:" + specifier);
  }
  const { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  );
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists && packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
    const packageJsonUrl2 = pathToFileURL(packageConfig.pjsonPath);
    return packageExportsResolve(
      packageJsonUrl2,
      packageSubpath,
      packageConfig,
      base,
      conditions
    );
  }
  let packageJsonUrl = new URL$1(
    "./node_modules/" + packageName + "/package.json",
    base
  );
  let packageJsonPath = fileURLToPath(packageJsonUrl);
  let lastPath;
  do {
    const stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat || !stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new URL$1(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = fileURLToPath(packageJsonUrl);
      continue;
    }
    const packageConfig2 = read(packageJsonPath, { base, specifier });
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new URL$1(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/") return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "") return false;
  if (specifier[0] === "/") return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol;
  const isData = protocol === "data:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new URL$1(specifier, base);
    } catch (error_) {
      const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      error.cause = error_;
      throw error;
    }
  } else if (protocol === "file:" && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new URL$1(specifier);
    } catch (error_) {
      if (isData && !nodeBuiltins.includes(specifier)) {
        const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        error.cause = error_;
        throw error;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  assert(resolved !== void 0, "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base);
}

const DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
const isWindows = /* @__PURE__ */ (() => process.platform === "win32")();
const NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
  "ERR_MODULE_NOT_FOUND",
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "MODULE_NOT_FOUND",
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  "ERR_PACKAGE_IMPORT_NOT_DEFINED"
]);
const globalCache = /* @__PURE__ */ (() => (
  // eslint-disable-next-line unicorn/no-unreadable-iife
  globalThis["__EXSOLVE_CACHE__"] ||= /* @__PURE__ */ new Map()
))();
function resolveModuleURL(input, options) {
  const parsedInput = _parseInput(input);
  if ("external" in parsedInput) {
    return parsedInput.external;
  }
  const specifier = parsedInput.specifier;
  let url = parsedInput.url;
  let absolutePath = parsedInput.absolutePath;
  let cacheKey;
  let cacheObj;
  if (options?.cache !== false) {
    cacheKey = _cacheKey(absolutePath || specifier, options);
    cacheObj = options?.cache && typeof options?.cache === "object" ? options.cache : globalCache;
  }
  if (cacheObj) {
    const cached = cacheObj.get(cacheKey);
    if (typeof cached === "string") {
      return cached;
    }
    if (cached instanceof Error) {
      if (options?.try) {
        return void 0;
      }
      throw cached;
    }
  }
  if (absolutePath) {
    try {
      const stat = lstatSync(absolutePath);
      if (stat.isSymbolicLink()) {
        absolutePath = realpathSync(absolutePath);
        url = pathToFileURL(absolutePath);
      }
      if (stat.isFile()) {
        if (cacheObj) {
          cacheObj.set(cacheKey, url.href);
        }
        return url.href;
      }
    } catch (error) {
      if (error?.code !== "ENOENT") {
        if (cacheObj) {
          cacheObj.set(cacheKey, error);
        }
        throw error;
      }
    }
  }
  const conditionsSet = options?.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
  const target = specifier || url.href;
  const bases = _normalizeBases(options?.from);
  const suffixes = options?.suffixes || [""];
  const extensions = options?.extensions ? ["", ...options.extensions] : [""];
  let resolved;
  for (const base of bases) {
    for (const suffix of suffixes) {
      let name = _join(target, suffix);
      if (name === ".") {
        name += "/.";
      }
      for (const extension of extensions) {
        resolved = _tryModuleResolve(name + extension, base, conditionsSet);
        if (resolved) {
          break;
        }
      }
      if (resolved) {
        break;
      }
    }
    if (resolved) {
      break;
    }
  }
  if (!resolved) {
    const error = new Error(
      `Cannot resolve module "${input}" (from: ${bases.map((u) => _fmtPath(u)).join(", ")})`
    );
    error.code = "ERR_MODULE_NOT_FOUND";
    if (cacheObj) {
      cacheObj.set(cacheKey, error);
    }
    if (options?.try) {
      return void 0;
    }
    throw error;
  }
  if (cacheObj) {
    cacheObj.set(cacheKey, resolved.href);
  }
  return resolved.href;
}
function resolveModulePath(id, options) {
  const resolved = resolveModuleURL(id, options);
  if (!resolved) {
    return void 0;
  }
  if (!resolved.startsWith("file://") && options?.try) {
    return void 0;
  }
  const absolutePath = fileURLToPath(resolved);
  return isWindows ? _normalizeWinPath(absolutePath) : absolutePath;
}
function _tryModuleResolve(specifier, base, conditions) {
  try {
    return moduleResolve(specifier, base, conditions);
  } catch (error) {
    if (!NOT_FOUND_ERRORS.has(error?.code)) {
      throw error;
    }
  }
}
function _normalizeBases(inputs) {
  const urls = (Array.isArray(inputs) ? inputs : [inputs]).flatMap(
    (input) => _normalizeBase(input)
  );
  if (urls.length === 0) {
    return [pathToFileURL("./")];
  }
  return urls;
}
function _normalizeBase(input) {
  if (!input) {
    return [];
  }
  if (_isURL(input)) {
    return [input];
  }
  if (typeof input !== "string") {
    return [];
  }
  if (/^(?:node|data|http|https|file):/.test(input)) {
    return new URL(input);
  }
  try {
    if (input.endsWith("/") || statSync(input).isDirectory()) {
      return pathToFileURL(input + "/");
    }
    return pathToFileURL(input);
  } catch {
    return [pathToFileURL(input + "/"), pathToFileURL(input)];
  }
}
function _fmtPath(input) {
  try {
    return fileURLToPath(input);
  } catch {
    return input;
  }
}
function _cacheKey(id, opts) {
  return JSON.stringify([
    id,
    (opts?.conditions || ["node", "import"]).sort(),
    opts?.extensions,
    opts?.from,
    opts?.suffixes
  ]);
}
function _join(a, b) {
  if (!a || !b || b === "/") {
    return a;
  }
  return (a.endsWith("/") ? a : a + "/") + (b.startsWith("/") ? b.slice(1) : b);
}
function _normalizeWinPath(path) {
  return path.replace(/\\/g, "/").replace(/^[a-z]:\//, (r) => r.toUpperCase());
}
function _isURL(input) {
  return input instanceof URL || input?.constructor?.name === "URL";
}
function _parseInput(input) {
  if (typeof input === "string") {
    if (input.startsWith("file:")) {
      const url = new URL(input);
      return { url, absolutePath: fileURLToPath(url) };
    }
    if (isAbsolute$1(input)) {
      return { url: pathToFileURL(input), absolutePath: input };
    }
    if (/^(?:node|data|http|https):/.test(input)) {
      return { external: input };
    }
    if (nodeBuiltins.includes(input) && !input.includes(":")) {
      return { external: `node:${input}` };
    }
    return { specifier: input };
  }
  if (_isURL(input)) {
    if (input.protocol === "file:") {
      return { url: input, absolutePath: fileURLToPath(input) };
    }
    return { external: input.href };
  }
  throw new TypeError("id must be a `string` or `URL`");
}

const defaultFindOptions = {
  startingFrom: ".",
  rootPattern: /^node_modules$/,
  reverse: false,
  test: (filePath) => {
    try {
      if (statSync(filePath).isFile()) {
        return true;
      }
    } catch {
    }
  }
};
async function findFile(filename, _options = {}) {
  const filenames = Array.isArray(filename) ? filename : [filename];
  const options = { ...defaultFindOptions, ..._options };
  const basePath = resolve(options.startingFrom);
  const leadingSlash = basePath[0] === "/";
  const segments = basePath.split("/").filter(Boolean);
  if (filenames.includes(segments.at(-1)) && await options.test(basePath)) {
    return basePath;
  }
  if (leadingSlash) {
    segments[0] = "/" + segments[0];
  }
  let root = segments.findIndex((r) => r.match(options.rootPattern));
  if (root === -1) {
    root = 0;
  }
  if (options.reverse) {
    for (let index = root + 1; index <= segments.length; index++) {
      for (const filename2 of filenames) {
        const filePath = join(...segments.slice(0, index), filename2);
        if (await options.test(filePath)) {
          return filePath;
        }
      }
    }
  } else {
    for (let index = segments.length; index > root; index--) {
      for (const filename2 of filenames) {
        const filePath = join(...segments.slice(0, index), filename2);
        if (await options.test(filePath)) {
          return filePath;
        }
      }
    }
  }
  throw new Error(
    `Cannot find matching ${filename} in ${options.startingFrom} or parent directories`
  );
}
function findNearestFile(filename, options = {}) {
  return findFile(filename, options);
}

function _resolvePath(id, opts = {}) {
  if (id instanceof URL || id.startsWith("file://")) {
    return normalize(fileURLToPath(id));
  }
  if (isAbsolute(id)) {
    return normalize(id);
  }
  return resolveModulePath(id, {
    ...opts,
    from: opts.from || opts.parent || opts.url
  });
}
const FileCache = /* @__PURE__ */ new Map();
async function readPackageJSON(id, options = {}) {
  const resolvedPath = await resolvePackageJSON(id, options);
  const cache = options.cache && typeof options.cache !== "boolean" ? options.cache : FileCache;
  if (options.cache && cache.has(resolvedPath)) {
    return cache.get(resolvedPath);
  }
  const blob = await promises.readFile(resolvedPath, "utf8");
  let parsed;
  try {
    parsed = x(blob);
  } catch {
    parsed = h(blob);
  }
  cache.set(resolvedPath, parsed);
  return parsed;
}
async function resolvePackageJSON(id = process.cwd(), options = {}) {
  return findNearestFile("package.json", {
    ...options,
    startingFrom: _resolvePath(id, options)
  });
}

function execCommand(cmd, cwd) {
  return execSync(cmd, { encoding: "utf8", cwd }).trim();
}

async function getLastGitTag(cwd) {
  try {
    return execCommand("git describe --tags --abbrev=0", cwd)?.split("\n").at(-1);
  } catch {
  }
}
function getCurrentGitBranch(cwd) {
  return execCommand("git rev-parse --abbrev-ref HEAD", cwd);
}
function getCurrentGitTag(cwd) {
  return execCommand("git tag --points-at HEAD", cwd);
}
function getCurrentGitRef(cwd) {
  return getCurrentGitTag(cwd) || getCurrentGitBranch(cwd);
}
function getGitRemoteURL(cwd, remote = "origin") {
  return execCommand(
    `git --work-tree="${cwd}" remote get-url "${remote}"`,
    cwd
  );
}
async function getGitDiff(from, to = "HEAD", cwd) {
  const r = execCommand(
    `git --no-pager log "${from ? `${from}...` : ""}${to}" --pretty="----%n%s|%h|%an|%ae%n%b" --name-status`,
    cwd
  );
  return r.split("----\n").splice(1).map((line) => {
    const [firstLine, ..._body] = line.split("\n");
    const [message, shortHash, authorName, authorEmail] = firstLine.split("|");
    const r2 = {
      message,
      shortHash,
      author: { name: authorName, email: authorEmail },
      body: _body.join("\n")
    };
    return r2;
  });
}
function parseCommits(commits, config) {
  return commits.map((commit) => parseGitCommit(commit, config)).filter(Boolean);
}
const ConventionalCommitRegex = /(?<emoji>:.+:|(\uD83C[\uDF00-\uDFFF])|(\uD83D[\uDC00-\uDE4F\uDE80-\uDEFF])|[\u2600-\u2B55])?( *)?(?<type>[a-z]+)(\((?<scope>.+)\))?(?<breaking>!)?: (?<description>.+)/i;
const CoAuthoredByRegex = /co-authored-by:\s*(?<name>.+)(<(?<email>.+)>)/gim;
const PullRequestRE = /\([ a-z]*(#\d+)\s*\)/gm;
const IssueRE = /(#\d+)/gm;
function parseGitCommit(commit, config) {
  const match = commit.message.match(ConventionalCommitRegex);
  if (!match) {
    return null;
  }
  const type = match.groups.type;
  const hasBreakingBody = /breaking change:/i.test(commit.body);
  let scope = match.groups.scope || "";
  scope = config.scopeMap[scope] || scope;
  const isBreaking = Boolean(match.groups.breaking || hasBreakingBody);
  let description = match.groups.description;
  const references = [];
  for (const m of description.matchAll(PullRequestRE)) {
    references.push({ type: "pull-request", value: m[1] });
  }
  for (const m of description.matchAll(IssueRE)) {
    if (!references.some((i) => i.value === m[1])) {
      references.push({ type: "issue", value: m[1] });
    }
  }
  references.push({ value: commit.shortHash, type: "hash" });
  description = description.replace(PullRequestRE, "").trim();
  const authors = [commit.author];
  for (const match2 of commit.body.matchAll(CoAuthoredByRegex)) {
    authors.push({
      name: (match2.groups.name || "").trim(),
      email: (match2.groups.email || "").trim()
    });
  }
  return {
    ...commit,
    authors,
    description,
    type,
    scope,
    references,
    isBreaking
  };
}

const providerToRefSpec = {
  github: { "pull-request": "pull", hash: "commit", issue: "issues" },
  gitlab: { "pull-request": "merge_requests", hash: "commit", issue: "issues" },
  bitbucket: {
    "pull-request": "pull-requests",
    hash: "commit",
    issue: "issues"
  }
};
const providerToDomain = {
  github: "github.com",
  gitlab: "gitlab.com",
  bitbucket: "bitbucket.org"
};
const domainToProvider = {
  "github.com": "github",
  "gitlab.com": "gitlab",
  "bitbucket.org": "bitbucket"
};
const providerURLRegex = /^(?:(?<user>[\w-]+)@)?(?:(?<provider>[^/:]+):)?(?<repo>[\w-]+\/(?:\w|\.(?!git$)|-)+)(?:\.git)?$/;
function baseUrl(config) {
  return `https://${config.domain}/${config.repo}`;
}
function formatReference(ref, repo) {
  if (!repo || !(repo.provider in providerToRefSpec)) {
    return ref.value;
  }
  const refSpec = providerToRefSpec[repo.provider];
  return `[${ref.value}](${baseUrl(repo)}/${refSpec[ref.type]}/${ref.value.replace(/^#/, "")})`;
}
function formatCompareChanges(v, config) {
  const part = config.repo.provider === "bitbucket" ? "branches/compare" : "compare";
  const changes = config.repo.provider === "bitbucket" ? `${v || config.to}%0D${config.from}` : `${config.from}...${v || config.to}`;
  return `[compare changes](${baseUrl(config.repo)}/${part}/${changes})`;
}
async function resolveRepoConfig(cwd) {
  const pkg = await readPackageJSON(cwd).catch(() => {
  });
  if (pkg && pkg.repository) {
    const url = typeof pkg.repository === "string" ? pkg.repository : pkg.repository.url;
    return getRepoConfig(url);
  }
  try {
    const gitRemote = getGitRemoteURL(cwd);
    if (gitRemote) {
      return getRepoConfig(gitRemote);
    }
  } catch {
  }
}
function getRepoConfig(repoUrl = "") {
  let provider;
  let repo;
  let domain;
  let url;
  try {
    url = new URL(repoUrl);
  } catch {
  }
  const m = repoUrl.match(providerURLRegex)?.groups ?? {};
  if (m.repo && m.provider) {
    repo = m.repo;
    provider = m.provider in domainToProvider ? domainToProvider[m.provider] : m.provider;
    domain = provider in providerToDomain ? providerToDomain[provider] : provider;
  } else if (url) {
    domain = url.hostname;
    const paths = url.pathname.split("/");
    repo = paths.slice(1).join("/").replace(/\.git$/, "");
    provider = domainToProvider[domain];
  } else if (m.repo) {
    repo = m.repo;
    provider = "github";
    domain = providerToDomain[provider];
  }
  return {
    provider,
    repo,
    domain
  };
}

async function generateMarkDown(commits, config) {
  const typeGroups = groupBy(commits, "type");
  const markdown = [];
  const breakingChanges = [];
  const v = config.newVersion && config.templates.tagBody.replaceAll("{{newVersion}}", config.newVersion);
  markdown.push("", "## " + (v || `${config.from || ""}...${config.to}`), "");
  if (config.repo && config.from) {
    markdown.push(formatCompareChanges(v, config));
  }
  for (const type in config.types) {
    const group = typeGroups[type];
    if (!group || group.length === 0) {
      continue;
    }
    markdown.push("", "### " + config.types[type].title, "");
    for (const commit of group.reverse()) {
      const line = formatCommit(commit, config);
      markdown.push(line);
      if (commit.isBreaking) {
        breakingChanges.push(line);
      }
    }
  }
  if (breakingChanges.length > 0) {
    markdown.push("", "#### \u26A0\uFE0F Breaking Changes", "", ...breakingChanges);
  }
  const _authors = /* @__PURE__ */ new Map();
  for (const commit of commits) {
    if (!commit.author) {
      continue;
    }
    const name = formatName(commit.author.name);
    if (!name || name.includes("[bot]")) {
      continue;
    }
    if (config.excludeAuthors && config.excludeAuthors.some(
      (v2) => name.includes(v2) || commit.author.email?.includes(v2)
    )) {
      continue;
    }
    if (_authors.has(name)) {
      const entry = _authors.get(name);
      entry.email.add(commit.author.email);
    } else {
      _authors.set(name, { email: /* @__PURE__ */ new Set([commit.author.email]) });
    }
  }
  await Promise.all(
    [..._authors.keys()].map(async (authorName) => {
      const meta = _authors.get(authorName);
      for (const email of meta.email) {
        const { user } = await l(`https://ungh.cc/users/find/${email}`).then((r) => r.json()).catch(() => ({ user: null }));
        if (user) {
          meta.github = user.username;
          break;
        }
      }
    })
  );
  const authors = [..._authors.entries()].map((e) => ({ name: e[0], ...e[1] }));
  if (authors.length > 0 && !config.noAuthors) {
    markdown.push(
      "",
      "### \u2764\uFE0F Contributors",
      "",
      ...authors.map((i) => {
        const _email = [...i.email].find(
          (e) => !e.includes("noreply.github.com")
        );
        const email = config.hideAuthorEmail !== true && _email ? ` <${_email}>` : "";
        const github = i.github ? ` ([@${i.github}](https://github.com/${i.github}))` : "";
        return `- ${i.name}${github || email || ""}`;
      })
    );
  }
  return convert(markdown.join("\n").trim(), true);
}
function formatCommit(commit, config) {
  return "- " + (commit.scope ? `**${commit.scope.trim()}:** ` : "") + (commit.isBreaking ? "\u26A0\uFE0F  " : "") + upperFirst(commit.description) + formatReferences(commit.references, config);
}
function formatReferences(references, config) {
  const pr = references.filter((ref) => ref.type === "pull-request");
  const issue = references.filter((ref) => ref.type === "issue");
  if (pr.length > 0 || issue.length > 0) {
    return " (" + [...pr, ...issue].map((ref) => formatReference(ref, config.repo)).join(", ") + ")";
  }
  if (references.length > 0) {
    return " (" + formatReference(references[0], config.repo) + ")";
  }
  return "";
}
function formatName(name = "") {
  return name.split(" ").map((p) => upperFirst(p.trim())).join(" ");
}
function groupBy(items, key) {
  const groups = {};
  for (const item of items) {
    groups[item[key]] = groups[item[key]] || [];
    groups[item[key]].push(item);
  }
  return groups;
}

const defaultOutput = "CHANGELOG.md";
const getDefaultConfig = () => ({
  types: {
    feat: { title: "\u{1F680} Enhancements", semver: "minor" },
    perf: { title: "\u{1F525} Performance", semver: "patch" },
    fix: { title: "\u{1FA79} Fixes", semver: "patch" },
    refactor: { title: "\u{1F485} Refactors", semver: "patch" },
    docs: { title: "\u{1F4D6} Documentation", semver: "patch" },
    build: { title: "\u{1F4E6} Build", semver: "patch" },
    types: { title: "\u{1F30A} Types", semver: "patch" },
    chore: { title: "\u{1F3E1} Chore" },
    examples: { title: "\u{1F3C0} Examples" },
    test: { title: "\u2705 Tests" },
    style: { title: "\u{1F3A8} Styles" },
    ci: { title: "\u{1F916} CI" }
  },
  cwd: null,
  from: "",
  to: "",
  output: defaultOutput,
  scopeMap: {},
  tokens: {
    github: process.env.CHANGELOGEN_TOKENS_GITHUB || process.env.GITHUB_TOKEN || process.env.GH_TOKEN
  },
  publish: {
    private: false,
    tag: "latest",
    args: []
  },
  templates: {
    commitMessage: "chore(release): v{{newVersion}}",
    tagMessage: "v{{newVersion}}",
    tagBody: "v{{newVersion}}"
  },
  excludeAuthors: [],
  noAuthors: false
});
async function loadChangelogConfig(cwd, overrides) {
  await setupDotenv({ cwd });
  const defaults = getDefaultConfig();
  const { config } = await loadConfig$1({
    cwd,
    name: "changelog",
    packageJson: true,
    defaults,
    overrides: {
      cwd,
      ...overrides
    }
  });
  return await resolveChangelogConfig(config, cwd);
}
async function resolveChangelogConfig(config, cwd) {
  if (!config.from) {
    config.from = await getLastGitTag(cwd);
  }
  if (!config.to) {
    config.to = await getCurrentGitRef(cwd);
  }
  if (config.output) {
    config.output = config.output === true ? defaultOutput : resolve$1(cwd, config.output);
  } else {
    config.output = false;
  }
  if (!config.repo) {
    config.repo = await resolveRepoConfig(cwd);
  }
  if (typeof config.repo === "string") {
    config.repo = getRepoConfig(config.repo);
  }
  return config;
}

async function getConventionalChangelog(commits) {
  if (!commits[0].type) {
    return commits.map((c) => c.message).join("\n");
  }
  const resolvedCommits = commits.map((c) => {
    if (c.type === "remove") {
      c.isBreaking = true;
    }
    return c;
  });
  const _config = await loadChangelogConfig(process$1.cwd(), {
    types: {
      add: { title: "\u{1F680} Enhancements", semver: "minor" },
      change: { title: "\u{1FA79} Fixes", semver: "patch" },
      remove: { title: "\u{1FA79} Fixes", semver: "minor" }
    },
    hideAuthorEmail: true
  });
  const md = await generateMarkDown(resolvedCommits, _config);
  return md.split("\n").slice(3).join("\n");
}
async function getGitCommits(currentTag, commitMessageTemplate) {
  const tags = execSync("git tag -l --sort=v:refname").toString().trim().split("\n");
  const currentTagIndex = tags.indexOf(currentTag);
  if (currentTagIndex === -1)
    throw new Error(`Tag "${currentTag}" not found.`);
  let previousTagIndex = currentTagIndex - 1;
  let previousTag;
  if (currentTagIndex === 0) {
    previousTag = void 0;
  } else if (currentTag.includes("-")) {
    previousTag = tags[previousTagIndex];
  } else {
    while (previousTagIndex >= 0 && tags[previousTagIndex].includes("-")) {
      previousTagIndex--;
    }
    if (previousTagIndex < 0)
      previousTag = void 0;
    else
      previousTag = tags[previousTagIndex];
  }
  const filterRegex = new RegExp(escapeRegExp(commitMessageTemplate));
  const rawCommits = (await getGitDiff(previousTag, currentTag)).filter((c) => !filterRegex.test(c.message));
  return parseCommits(rawCommits, { scopeMap: {} });
}

const mimeTypes = {
  json: "application/json",
  xpi: "application/x-xpinstall"
};
function getMimeTypeByFileName(filename) {
  const ext = extname$1(filename);
  for (const type in mimeTypes) {
    if (ext === `.${type}`)
      return mimeTypes[type];
  }
  return void 0;
}

class GitHub extends ReleaseBase {
  client;
  constructor(ctx) {
    super(ctx);
    this.client = this.getClient();
  }
  async run() {
    this.checkFiles();
    this.logger.info("Uploading XPI to GitHub...");
    await this.uploadXPI();
    this.logger.info("Refreshing update manifest...");
    await this.refreshUpdateManifest();
    return this.ctx;
  }
  /**
   * Create new release and upload XPI to asset
   */
  async uploadXPI() {
    const { version, dist, xpiName } = this.ctx;
    const release = await this.createRelease({
      ...this.remote,
      tag_name: this.ctx.release.bumpp.tag.toString().replaceAll("%s", version),
      name: `Release v${version}`,
      body: await this.getChangelog(),
      prerelease: version.includes("-"),
      make_latest: "true"
    });
    if (!release)
      throw new Error("Create release failed!");
    this.logger.debug("Uploading xpi asset...");
    await this.uploadAsset(release.id, join$1(dist, `${xpiName}.xpi`));
  }
  async getReleaseByTag(tag) {
    return await this.client.rest.repos.getReleaseByTag({
      ...this.remote,
      tag
    }).catch((e) => {
      this.logger.debug(`Release with tag ${tag} not found. ${e}`);
      return void 0;
    }).then((res) => {
      if (res && res.status === 200) {
        this.logger.debug(`Found release with tag "${tag}", id=${res.data.id}.`);
        return res.data;
      }
    });
  }
  async createRelease(options) {
    this.logger.debug("Creating release...");
    this.logger.debug(options);
    return await this.client.rest.repos.createRelease(options).catch((e) => {
      this.logger.error(e);
      throw new Error("Create release failed.");
    }).then((res) => {
      if (res.status === 201) {
        this.logger.debug(`Create release "${res.data.tag_name}" success, id: ${res.data.id}.`);
        return res.data;
      }
    });
  }
  async uploadAsset(releaseID, asset) {
    this.logger.debug(`Uploading ${asset} to release ${releaseID}`);
    return await this.client.rest.repos.uploadReleaseAsset({
      ...this.remote,
      release_id: releaseID,
      data: await readFile(asset),
      headers: {
        "content-type": getMimeTypeByFileName(asset) || "application/octet-stream",
        "content-length": (await stat(asset)).size
      },
      name: basename(asset)
    }).then((res) => {
      this.logger.debug(`Upload "${res.data.name}" success, assetId: ${res.data.id}`);
      return res.data;
    });
  }
  async refreshUpdateManifest() {
    const updater = this.ctx.release.github.updater;
    if (!updater) {
      this.logger.debug(`Skip refresh update.json because release.github.updater = false`);
      return;
    }
    const { dist, version } = this.ctx;
    const assets = (await glob(`${dist}/update*.json`)).map((p) => basename(p));
    const release = await this.getReleaseByTag(updater) ?? await this.createRelease({
      ...this.remote,
      tag_name: updater,
      prerelease: true,
      make_latest: "false"
    });
    if (!release)
      throw new Error("Get or create 'release' failed.");
    const existAssets = await this.client.rest.repos.listReleaseAssets({
      ...this.remote,
      release_id: release.id
    }).then((res) => {
      return res.data.filter((asset) => assets.includes(asset.name));
    });
    if (existAssets) {
      for (const existAsset of existAssets) {
        if (assets.includes(existAsset.name)) {
          this.logger.debug(`Delete existed asset ${existAsset.name} in release ${updater}`);
          await this.client.rest.repos.deleteReleaseAsset({
            ...this.remote,
            asset_id: existAsset.id
          });
        }
      }
    }
    for (const asset of assets) {
      await this.uploadAsset(release.id, join$1(dist, asset));
    }
    await this.client.rest.repos.updateRelease({
      ...this.remote,
      release_id: release.id,
      name: "Release Manifest",
      body: `This release is used to host \`update.json\`, please do not delete or modify it! 
 Updated in UTC ${(/* @__PURE__ */ new Date()).toISOString()} for version ${version}`,
      prerelease: true,
      make_latest: "false"
    });
  }
  async getChangelog() {
    const { release } = this.ctx;
    const { github } = release;
    const { releaseNote } = github;
    return releaseNote(this.ctx);
  }
  getClient() {
    if (!process$1.env.GITHUB_TOKEN)
      throw new Error("No GITHUB_TOKEN.");
    const client = new Octokit({
      auth: process$1.env.GITHUB_TOKEN,
      userAgent: "zotero-plugin-scaffold"
    });
    return client;
  }
  get remote() {
    const [owner, repo] = this.ctx.release.github.repository.split("/");
    return {
      owner,
      repo
    };
  }
}

class Release extends Base {
  constructor(ctx) {
    super(ctx);
  }
  /**
   * Runs release
   *
   * if is not CI，bump version, git add (package.json), git commit, git tag, git push;
   * if is CI, do not bump version, do not run git, create release (tag is `v${version}`) and upload xpi,
   *    then, create or update release (tag is "release"), update `update.json`.
   */
  async run() {
    const t = /* @__PURE__ */ new Date();
    const { release, version } = this.ctx;
    if (release.bumpp.release === "prompt" && isCI) {
      this.logger.warn("Config `release.bumpp.release == 'prompt'` will do nothing because in CI enviroment.");
      this.ctx.release.bumpp.release = version;
    }
    if (release.bumpp.confirm && isCI) {
      this.logger.warn("Config `release.bumpp.confirm` will do nothing because in CI enviroment.");
      this.ctx.release.bumpp.confirm = false;
    }
    const isBumpNeeded = this.ctx.release.bumpp.release !== version;
    const isGitHubEnabled = this.isEnabled(release.github.enable);
    const isPublishNeeded = isGitHubEnabled;
    if (isPublishNeeded && !release.bumpp.execute) {
      this.logger.warn(`The current release needs to run the build after bumping the version number, please configure the build script in 'config.release.bumpp.execute'${isBumpNeeded ? "" : " or run build before run release"}.`);
      this.ctx.release.bumpp.execute ||= "npm run build";
    }
    this.logger.debug(`Release config: ", ${this.ctx.release}`);
    await this.ctx.hooks.callHook("release:init", this.ctx);
    await new Bump(this.ctx).run();
    await this.ctx.hooks.callHook("release:push", this.ctx);
    this.ctx.release.changelog = await this.getChangelog();
    if (isGitHubEnabled) {
      await new GitHub(this.ctx).run();
    }
    await this.ctx.hooks.callHook("release:done", this.ctx);
    this.logger.success(
      `Done in ${((/* @__PURE__ */ new Date()).getTime() - t.getTime()) / 1e3} s.`
    );
  }
  async getChangelog() {
    const { commit, tag } = this.ctx.release.bumpp;
    let changelog;
    const rawCommit = await getGitCommits(tag, commit);
    if (rawCommit.length === 0) {
      return "_No significant changes._";
    }
    const changelogConfig = this.ctx.release.changelog;
    if (typeof changelogConfig == "function") {
      changelog = changelogConfig(this.ctx, rawCommit);
    } else if (!!changelogConfig && typeof changelogConfig == "string") {
      changelog = execSync(changelogConfig).toString().trim();
    } else {
      changelog = await getConventionalChangelog(rawCommit);
    }
    this.logger.debug(`Got changelog:
${changelog}
`);
    return changelog;
  }
  isEnabled(enable) {
    if (enable === "always")
      return true;
    if (enable === "ci" && isCI)
      return true;
    if (enable === "local" && !isCI)
      return true;
    return false;
  }
  exit() {
  }
  get resolvedCommitMessage() {
    return this.ctx.release.bumpp.commit.replace("%s", this.ctx.version);
  }
}

function watch(source, ignore, event) {
  const watcher = chokidar.watch(source, {
    ignored: [
      /(^|[/\\])\../,
      // ignore dotfiles
      /[\\/]\.git[\\/]/,
      /[\\/]node_modules[\\/]/,
      ...toArray(ignore)
    ],
    ignoreInitial: true,
    ignorePermissionErrors: true,
    persistent: true
  });
  const onChangeDebounced = safeDebounce(event.onChange);
  const onAddDebounced = safeDebounce(event.onAdd);
  watcher.on("ready", async () => {
    if (event.onReady)
      await event.onReady();
    logger.clear();
    logger.ready("Server Ready!");
  }).on("change", async (path) => {
    logger.clear();
    logger.info(`${path} changed`);
    await onChangeDebounced(path);
  }).on("add", async (path, stats) => {
    if (event.onAdd)
      await onAddDebounced(path, stats);
  }).on("error", async (err) => {
    if (event.onError)
      await event.onError(err);
    logger.fail("Server start failed!");
    logger.error(err);
  });
}
function safeDebounce(fn) {
  if (!fn)
    return () => {
    };
  return debounce(async (...args) => {
    try {
      await fn(...args);
    } catch (error) {
      logger.error(error);
    }
  }, 500);
}

function isRunning(query) {
  let cmd = "";
  switch (process$1.platform) {
    case "win32":
      cmd = `tasklist`;
      break;
    case "darwin":
      cmd = `ps -ax | grep ${query}`;
      break;
    case "linux":
      cmd = `ps -A`;
      break;
  }
  try {
    const stdout = execSync(cmd, { encoding: "utf8" });
    return stdout.toLowerCase().includes(query.toLowerCase());
  } catch {
    return false;
  }
}
const ExitSignals = ["exit", "SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"];

const prefsCommon = {
  // Allow debug output via dump to be printed to the system console
  "browser.dom.window.dump.enabled": true,
  // From:
  // https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/internals/preferences.html#data-choices-notification
  // This is the data submission master kill switch. If disabled, no policy is shown or upload takes place, ever.
  "datareporting.policy.dataSubmissionEnabled": false,
  // Allow remote connections to the debugger.
  "devtools.debugger.remote-enabled": true,
  // Disable the prompt for allowing connections.
  "devtools.debugger.prompt-connection": false,
  // Allow extensions to log messages on browser's console.
  "devtools.browserconsole.contentMessages": true,
  // Turn off platform logging because it is a lot of info.
  "extensions.logging.enabled": false,
  // Disable extension updates and notifications.
  "extensions.checkCompatibility.nightly": false,
  "extensions.update.enabled": false,
  "extensions.update.notifyUser": false,
  // From:
  // http://hg.mozilla.org/mozilla-central/file/1dd81c324ac7/build/automation.py.in//l372
  // Only load extensions from the application and user profile.
  // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION
  "extensions.enabledScopes": 5,
  // Disable metadata caching for installed add-ons by default.
  "extensions.getAddons.cache.enabled": false,
  // Disable installing any distribution add-ons.
  "extensions.installDistroAddons": false,
  // Allow installing extensions dropped into the profile folder.
  "extensions.autoDisableScopes": 10,
  // Disable app update.
  "app.update.enabled": false,
  // Allow unsigned add-ons.
  "xpinstall.signatures.required": false,
  // browser.link.open_newwindow is changed from 3 to 2 in:
  // https://github.com/saadtazi/firefox-profile-js/blob/cafc793d940a779d280103ae17d02a92de862efc/lib/firefox_profile.js#L32
  // Restore original value to avoid https://github.com/mozilla/web-ext/issues/1592
  "browser.link.open_newwindow": 3
};
const prefsFirefox = {
  "browser.startup.homepage": "about:blank",
  "startup.homepage_welcome_url": "about:blank",
  "startup.homepage_welcome_url.additional": "",
  "devtools.errorconsole.enabled": true,
  "devtools.chrome.enabled": true,
  // From:
  // http://hg.mozilla.org/mozilla-central/file/1dd81c324ac7/build/automation.py.in//l388
  // Make url-classifier updates so rare that they won't affect tests.
  "urlclassifier.updateinterval": 172800,
  // Point the url-classifier to a nonexistent local URL for fast failures.
  "browser.safebrowsing.provider.0.gethashURL": "http://localhost/safebrowsing-dummy/gethash",
  "browser.safebrowsing.provider.0.keyURL": "http://localhost/safebrowsing-dummy/newkey",
  "browser.safebrowsing.provider.0.updateURL": "http://localhost/safebrowsing-dummy/update",
  // Disable self repair/SHIELD
  "browser.selfsupport.url": "https://localhost/selfrepair",
  // Disable Reader Mode UI tour
  "browser.reader.detectedFirstArticle": true,
  // Set the policy firstURL to an empty string to prevent
  // the privacy info page to be opened on every "web-ext run".
  // (See #1114 for rationale)
  "datareporting.policy.firstRunURL": ""
};
const prefsZotero = {
  "extensions.experiments.enabled": true,
  "extensions.autoDisableScopes": 0,
  // Enable remote-debugging
  "devtools.debugger.remote-enabled": true,
  "devtools.debugger.remote-websocket": true,
  "devtools.debugger.prompt-connection": false,
  // Inherit the default test settings from Zotero
  // https://github.com/zotero/zotero/blob/8a06edab49f07b84d07056ccd594c87920ef2c5e/test/runtests.sh#L127-L147
  // "app.update.enabled": false,
  // "extensions.zotero.sync.server.compressData": false,
  // "extensions.zotero.automaticScraperUpdates": false,
  // "extensions.zotero.debug.log": 5,
  // "extensions.zotero.debug.level": 5,
  // "extensions.zotero.debug.time": 5,
  "extensions.zotero.firstRun.skipFirefoxProfileAccessCheck": true,
  "extensions.zotero.firstRunGuidance": false,
  "extensions.zotero.firstRun2": false,
  "extensions.zotero.reportTranslationFailure": false,
  "extensions.zotero.httpServer.enabled": true,
  "extensions.zotero.httpServer.port": 23124,
  // ascii "ZT"
  "extensions.zotero.httpServer.localAPI.enabled": true,
  // "extensions.zotero.backup.numBackups": 0,
  // "extensions.zotero.sync.autoSync": false,
  "extensions.zoteroMacWordIntegration.installed": true,
  "extensions.zoteroMacWordIntegration.skipInstallation": true,
  "extensions.zoteroWinWordIntegration.skipInstallation": true,
  "extensions.zoteroOpenOfficeIntegration.skipInstallation": true
};
const prefs = {
  ...prefsCommon,
  ...prefsFirefox,
  ...prefsZotero
};

const UNSOLICITED_EVENTS = /* @__PURE__ */ new Set([
  "tabNavigated",
  "styleApplied",
  "propertyChange",
  "networkEventUpdate",
  "networkEvent",
  "propertyChange",
  "newMutations",
  "frameUpdate",
  "tabListChanged"
]);
function parseMessage(data) {
  const dataString = data.toString();
  const separatorIndex = dataString.indexOf(":");
  if (separatorIndex < 1) {
    return { remainingData: data };
  }
  const messageLength = Number.parseInt(dataString.substring(0, separatorIndex), 10);
  if (Number.isNaN(messageLength)) {
    return {
      remainingData: data,
      error: new Error("Error parsing RDP message length"),
      fatal: true
    };
  }
  if (data.length - (separatorIndex + 1) < messageLength) {
    return { remainingData: data };
  }
  const messageContent = data.slice(
    separatorIndex + 1,
    separatorIndex + 1 + messageLength
  );
  const remainingData = data.slice(separatorIndex + 1 + messageLength);
  try {
    const parsedMessage = JSON.parse(messageContent.toString());
    return { remainingData, parsedMessage };
  } catch (error) {
    return { remainingData, error, fatal: false };
  }
}
class MessagingClient extends EventEmitter {
  incomingData = Buffer.alloc(0);
  pendingRequests = [];
  activeRequests = /* @__PURE__ */ new Map();
  connection;
  constructor() {
    super();
  }
  async connect(port) {
    await new Promise((resolve, reject) => {
      const d = domain.create();
      d.once("error", reject);
      d.run(() => {
        const connectionOptions = { port, host: "127.0.0.1" };
        const conn = net.createConnection(connectionOptions, () => {
          resolve();
        });
        this.connection = conn;
        conn.on("data", this.onData.bind(this));
        conn.on("error", reject);
        conn.on("end", this.onEnd.bind(this));
        conn.on("timeout", this.onTimeout.bind(this));
        this.expectReply("root", { resolve, reject });
      });
    });
  }
  disconnect() {
    if (!this.connection)
      return;
    this.connection.removeAllListeners();
    this.connection.end();
    this.rejectAllRequests(
      new Error("RDP connection closed")
    );
  }
  rejectAllRequests(error) {
    this.activeRequests.forEach((deferred) => {
      deferred.reject(error);
    });
    this.activeRequests.clear();
    this.pendingRequests.forEach(({ deferred }) => {
      deferred.reject(error);
    });
    this.pendingRequests = [];
  }
  async request(requestProps) {
    const request = typeof requestProps === "string" ? { to: "root", type: requestProps } : requestProps;
    if (!request.to) {
      throw new Error(`Unexpected RDP request without target actor: ${request.type}`);
    }
    return await new Promise((resolve, reject) => {
      const deferred = { resolve, reject };
      this.pendingRequests.push({ request, deferred });
      this.flushPendingRequests();
    });
  }
  flushPendingRequests() {
    this.pendingRequests = this.pendingRequests.filter(
      ({ request, deferred }) => {
        if (this.activeRequests.has(request.to))
          return true;
        if (!this.connection) {
          throw new Error("RDP connection closed");
        }
        try {
          const messageString = `${Buffer.from(JSON.stringify(request)).length}:${JSON.stringify(request)}`;
          this.connection.write(messageString);
          this.expectReply(request.to, deferred);
        } catch (err) {
          deferred.reject(err);
        }
        return false;
      }
    );
  }
  expectReply(targetActor, deferred) {
    if (this.activeRequests.has(targetActor)) {
      throw new Error(`${targetActor} does already have an active request`);
    }
    this.activeRequests.set(targetActor, deferred);
  }
  onData(data) {
    this.incomingData = Buffer.concat([this.incomingData, data]);
    while (this.readMessage()) ;
  }
  readMessage() {
    const { remainingData, parsedMessage, error, fatal } = parseMessage(
      this.incomingData
    );
    this.incomingData = remainingData;
    if (error) {
      this.emit(
        "error",
        new Error(`Error parsing RDP packet: ${String(error)}`)
      );
      if (fatal)
        this.disconnect();
      return !fatal;
    }
    if (!parsedMessage)
      return false;
    this.handleMessage(parsedMessage);
    return true;
  }
  handleMessage(message) {
    if (!message.from) {
      if (message.error) {
        this.emit("rdp-error", message);
        return;
      }
      this.emit(
        "error",
        new Error(`Received an RDP message without a sender actor: ${JSON.stringify(message)}`)
      );
      return;
    }
    if (message.type && UNSOLICITED_EVENTS.has(message.type)) {
      this.emit("unsolicited-event", message);
      return;
    }
    if (this.activeRequests.has(message.from)) {
      const deferred = this.activeRequests.get(message.from);
      this.activeRequests.delete(message.from);
      if (message.error) {
        deferred?.reject(message);
      } else {
        deferred?.resolve(message);
      }
      this.flushPendingRequests();
      return;
    }
    if (message.type === "addonListChanged")
      return;
    this.emit(
      "error",
      new Error(`Received unexpected message:
 ${JSON.stringify(message)}`)
    );
  }
  onError(error) {
    this.emit("error", error);
  }
  onEnd() {
    this.emit("end");
  }
  onTimeout() {
    this.emit("timeout");
  }
}

const MAX_RETRIES = 150;
const RETRY_INTERVAL = 1e3;
function requestErrorToMessage(err) {
  if (err instanceof Error) {
    return String(err);
  }
  return `${err.error}: ${err.message}`;
}
function isErrorWithCode(codeWanted, error) {
  if (Array.isArray(codeWanted) && codeWanted.includes(error.code)) {
    return true;
  } else if (error.code === codeWanted) {
    return true;
  }
  return false;
}
class RemoteFirefox {
  client;
  checkedForAddonReloading;
  constructor() {
    this.client = new MessagingClient();
    this.checkedForAddonReloading = false;
    this.client.on("disconnect", () => {
      logger.debug('Received "disconnect" from Firefox client');
    });
    this.client.on("end", () => {
      logger.debug('Received "end" from Firefox client');
    });
    this.client.on("unsolicited-event", (info) => {
      logger.debug(`Received message from client: ${JSON.stringify(info)}`);
    });
    this.client.on("rdp-error", (rdpError) => {
      logger.debug(`Received error from client: ${JSON.stringify(rdpError)}`);
    });
    this.client.on("error", (error) => {
      logger.debug(`Received error from client: ${String(error)}`);
    });
  }
  async connect(port) {
    let lastError;
    for (const _ of Array.from({ length: MAX_RETRIES })) {
      try {
        this.client = new MessagingClient();
        await this.client.connect(port);
        return this.client;
      } catch (error) {
        logger.debug("Failed to connecte to RDP client, retry...");
        if (isErrorWithCode("ECONNREFUSED", error)) {
          await new Promise((resolve) => setTimeout(resolve, RETRY_INTERVAL));
          lastError = error;
        } else {
          throw error;
        }
      }
    }
    logger.error(`Unable to connect to Zotero. Too many retries.`);
    throw lastError;
  }
  disconnect() {
    this.client.disconnect();
  }
  async addonRequest(addon, request) {
    try {
      const response = await this.client.request({
        to: addon.actor,
        type: request
      });
      return response;
    } catch (err) {
      logger.debug(`Client responded to '${request}' request with error: ${err}`);
      const message = requestErrorToMessage(err);
      throw new Error(`Remote Firefox: addonRequest() error: ${message}`);
    }
  }
  async getAddonsActor() {
    try {
      const response = await this.client.request("getRoot");
      if (response.addonsActor == null) {
        return Promise.reject(
          new Error(
            "This version of Firefox does not provide an add-ons actor for remote installation."
          )
        );
      }
      return response.addonsActor;
    } catch (err) {
      logger.debug(`Falling back to listTabs because getRoot failed", ${err}`);
    }
    try {
      const response = await this.client.request("listTabs");
      if (response.addonsActor == null) {
        logger.debug(
          `listTabs returned a falsey addonsActor: ${JSON.stringify(response)}`
        );
        return Promise.reject(
          new Error(
            "This is an older version of Firefox that does not provide an add-ons actor for remote installation. Try Firefox 49 or higher."
          )
        );
      }
      return response.addonsActor;
    } catch (err) {
      logger.debug(`listTabs error: ${err}`);
      const message = requestErrorToMessage(err);
      throw new Error(`Remote Firefox: listTabs() error: ${message}`);
    }
  }
  async installTemporaryAddon(addonPath) {
    const addonsActor = await this.getAddonsActor();
    try {
      const response = await this.client.request({
        to: addonsActor,
        type: "installTemporaryAddon",
        addonPath
        // openDevTools: true,
      });
      logger.debug(`installTemporaryAddon: ${JSON.stringify(response)}`);
      logger.info(`Installed ${addonPath} as a temporary add-on`);
      return response;
    } catch (err) {
      const message = requestErrorToMessage(err);
      throw new Error(`installTemporaryAddon: Error: ${message}`);
    }
  }
  async getInstalledAddon(addonId) {
    try {
      const response = await this.client.request("listAddons");
      for (const addon of response.addons) {
        if (addon.id === addonId) {
          return addon;
        }
      }
      logger.debug(
        `Remote Firefox has these addons: ${response.addons.map((a) => a.id)}`
      );
      return Promise.reject(
        new Error(
          "The remote Firefox does not have your extension installed"
        )
      );
    } catch (err) {
      const message = requestErrorToMessage(err);
      throw new Error(`Remote Firefox: listAddons() error: ${message}`);
    }
  }
  async checkForAddonReloading(addon) {
    if (this.checkedForAddonReloading) {
      return addon;
    } else {
      const response = await this.addonRequest(addon, "requestTypes");
      if (!response.requestTypes.includes("reload")) {
        const supportedRequestTypes = JSON.stringify(response.requestTypes);
        logger.debug(`Remote Firefox only supports: ${supportedRequestTypes}`);
        throw new Error(
          "This Firefox version does not support add-on reloading. Re-run with --no-reload"
        );
      } else {
        this.checkedForAddonReloading = true;
        return addon;
      }
    }
  }
  async reloadAddon(addonId) {
    const addon = await this.getInstalledAddon(addonId);
    await this.checkForAddonReloading(addon);
    await this.addonRequest(addon, "reload");
    logger.success(`Last extension reload: ${(/* @__PURE__ */ new Date()).toTimeString()}`);
  }
}
function findFreeTcpPort() {
  return new Promise((resolve) => {
    const srv = net.createServer();
    srv.listen(0, "127.0.0.1", () => {
      const addr = srv.address();
      if (addr && typeof addr !== "string") {
        const freeTcpPort = addr.port;
        srv.close(() => resolve(freeTcpPort));
      }
    });
  });
}

const default_options = {
  binary: {
    // path: "",
    args: [],
    devtools: true
  },
  profile: {
    path: "./.scaffold/profile",
    dataDir: "",
    // keepChanges: true,
    createIfMissing: true,
    customPrefs: {}
  },
  plugins: {
    asProxy: false,
    list: []
  }
};
class ZoteroRunner {
  options;
  remoteFirefox = new RemoteFirefox();
  zotero;
  constructor(options) {
    this.options = toMerged(default_options, options);
    if (!options.binary.path)
      throw new Error("Binary path must be provided.");
    if (!options.profile.path && !options.profile.dataDir)
      this.options.profile.dataDir = "./.scaffold/data";
    logger.debug(this.options);
  }
  get default_profile_path() {
    return default_options.profile.path;
  }
  async run() {
    await this.setupProfile();
    await this.startZoteroInstance();
    if (!this.options.plugins.asProxy)
      await this.installTemporaryPlugins();
  }
  /**
   * Preparing the development environment
   *
   * When asProxy=true, generate a proxy file and replace prefs.
   *
   * @see https://www.zotero.org/support/dev/client_coding/plugin_development#setting_up_a_plugin_development_environment
   */
  async setupProfile() {
    const { path, createIfMissing } = this.options.profile;
    if (!await pathExists(path)) {
      if (createIfMissing)
        await this.createProfile(this.default_profile_path);
      else
        throw new Error("The 'profile.path' must be provided when 'createIfMissing' is false.");
    }
    const prefsPath = join$1(this.options.profile.path, "prefs.js");
    const prefsManager = new PrefsManager("user_pref");
    prefsManager.setPrefs(prefs);
    prefsManager.setPrefs(this.options.profile.customPrefs);
    if (await pathExists(prefsPath))
      await prefsManager.read(prefsPath);
    prefsManager.setPrefs({
      "extensions.lastAppBuildId": null,
      "extensions.lastAppVersion": null
    });
    await prefsManager.write(prefsPath);
    if (this.options.plugins.asProxy) {
      await this.installProxyPlugins();
    }
  }
  async createProfile(path) {
    logger.debug(`Creating profile at ${this.default_profile_path}...`);
    await ensureDir(path);
  }
  // private async copyProfile(from: string, to = this.default_profile_path) {
  //   logger.debug(`Copying profile from '${this.options.profile.path}' to ${this.default_profile_path}...`);
  //   await copy(from, to);
  //   this.options.profile.path = to;
  // }
  async startZoteroInstance() {
    let args = ["--purgecaches", "no-remote"];
    if (this.options.profile.path) {
      args.push("-profile", resolve$1(this.options.profile.path));
    }
    if (this.options.profile.dataDir) {
      args.push("--dataDir", resolve$1(this.options.profile.dataDir));
    }
    if (this.options.binary.devtools) {
      args.push("--jsdebugger");
    }
    if (this.options.binary.args) {
      args = [...args, ...this.options.binary.args];
    }
    const remotePort = await findFreeTcpPort();
    args.push("-start-debugger-server", String(remotePort));
    logger.debug(`Zotero start args: ${args}`);
    const env = {
      ...process$1.env,
      XPCOM_DEBUG_BREAK: "stack",
      NS_TRACE_MALLOC_DISABLE_STACKS: "1"
    };
    if (!await pathExists(this.options.binary.path))
      throw new Error("The Zotero binary not found.");
    this.zotero = spawn(this.options.binary.path, args, { env });
    logger.debug(`Zotero started, pid: ${this.zotero.pid}`);
    this.zotero.stdout?.on("data", (_data) => {
    });
    logger.debug("Connecting to the remote Firefox debugger...");
    await this.remoteFirefox.connect(remotePort);
    logger.debug(`Connected to the remote Firefox debugger on port: ${remotePort}`);
  }
  async installTemporaryPlugins() {
    for (const plugin of this.options.plugins.list) {
      const addonId = await this.remoteFirefox.installTemporaryAddon(resolve$1(plugin.sourceDir)).then((installResult) => {
        return installResult.addon.id;
      });
      if (!addonId) {
        throw new Error("Unexpected missing addonId in the installAsTemporaryAddon result");
      }
    }
  }
  async installProxyPlugin(id, sourceDir) {
    const addonProxyFilePath = join$1(this.options.profile.path, `extensions/${id}`);
    const buildPath = resolve$1(sourceDir);
    await outputFile(addonProxyFilePath, buildPath);
    logger.debug(
      [
        `Addon proxy file has been updated.`,
        `  File path: ${addonProxyFilePath}`,
        `  Addon path: ${buildPath}`
      ].join("\n")
    );
    const addonXpiFilePath = join$1(this.options.profile.path, `extensions/${id}.xpi`);
    if (await pathExists(addonXpiFilePath)) {
      await remove(addonXpiFilePath);
      logger.debug(`XPI file found, removed.`);
    }
    const addonInfoFilePath = join$1(this.options.profile.path, "extensions.json");
    if (await pathExists(addonInfoFilePath)) {
      const content = await readJSON(addonInfoFilePath);
      content.addons = content.addons.map((addon) => {
        if (addon.id === id && addon.active === false) {
          addon.active = true;
          addon.userDisabled = false;
          logger.debug(`Active plugin ${id} in extensions.json.`);
        }
        return addon;
      });
      await outputJSON(addonInfoFilePath, content);
    }
  }
  async installProxyPlugins() {
    for (const { id, sourceDir } of this.options.plugins.list) {
      await this.installProxyPlugin(id, sourceDir);
    }
  }
  async reloadTemporaryPluginById(id) {
    await this.remoteFirefox.reloadAddon(id);
  }
  async reloadTemporaryPluginBySourceDir(sourceDir) {
    const addonId = this.options.plugins.list.find((p) => p.sourceDir === sourceDir)?.id;
    if (!addonId) {
      return {
        sourceDir,
        reloadError: new Error(
          `Extension not reloadable: no addonId has been mapped to "${sourceDir}"`
        )
      };
    }
    try {
      await this.remoteFirefox.reloadAddon(addonId);
    } catch (error) {
      return {
        sourceDir,
        reloadError: error
      };
    }
    return { sourceDir, reloadError: void 0 };
  }
  async reloadAllTemporaryPlugins() {
    for (const { sourceDir } of this.options.plugins.list) {
      const res = await this.reloadTemporaryPluginBySourceDir(sourceDir);
      if (res.reloadError instanceof Error) {
        logger.error(res.reloadError);
      }
    }
  }
  async reloadProxyPluginByZToolkit(id, name, version) {
    const reloadScript = `
    (async () => {
    Services.obs.notifyObservers(null, "startupcache-invalidate", null);
    const { AddonManager } = ChromeUtils.import("resource://gre/modules/AddonManager.jsm");
    const addon = await AddonManager.getAddonByID("${id}");
    await addon.reload();
    const progressWindow = new Zotero.ProgressWindow({ closeOnClick: true });
    progressWindow.changeHeadline("${name} Hot Reload");
    progressWindow.progress = new progressWindow.ItemProgress(
        "chrome://zotero/skin/tick.png",
        "VERSION=${version}, BUILD=${(/* @__PURE__ */ new Date()).toLocaleString()}. By zotero-plugin-toolkit"
    );
    progressWindow.progress.setProgress(100);
    progressWindow.show();
    progressWindow.startCloseTimer(5000);
    })()`;
    const url = `zotero://ztoolkit-debug/?run=${encodeURIComponent(
      reloadScript
    )}`;
    const startZoteroCmd = `"${this.options.binary.path}" --purgecaches -profile "${this.options.profile.path}"`;
    const command = `${startZoteroCmd} -url "${url}"`;
    execSync(command);
  }
  // Do not use this method if possible,
  // as frequent execSync can cause Zotero to crash.
  async reloadAllProxyPlugins() {
    for (const { id } of this.options.plugins.list) {
      await this.reloadProxyPluginByZToolkit(id, id, id);
      await delay(2e3);
    }
  }
  async reloadAllPlugins() {
    if (this.options.plugins.asProxy)
      await this.reloadAllProxyPlugins();
    else
      await this.reloadAllTemporaryPlugins();
  }
  exit() {
    this.zotero?.kill();
    killZotero();
  }
}
function killZotero() {
  function kill() {
    try {
      if (process$1.env.ZOTERO_PLUGIN_KILL_COMMAND) {
        execSync(process$1.env.ZOTERO_PLUGIN_KILL_COMMAND);
      } else if (isWindows$1) {
        execSync("taskkill /f /im zotero.exe");
      } else if (isMacOS) {
        execSync("kill -9 $(ps -x | grep zotero)");
      } else if (isLinux) {
        execSync("pkill -9 zotero");
      } else {
        logger.error("No commands found for this operating system.");
      }
    } catch {
      logger.fail("Kill Zotero failed.");
    }
  }
  if (isRunning("zotero")) {
    kill();
  } else {
    logger.fail("No Zotero instance is currently running.");
  }
}

class Serve extends Base {
  builder;
  runner;
  _zoteroBinPath;
  constructor(ctx) {
    super(ctx);
    process$1.env.NODE_ENV ??= "development";
    this.builder = new Build(ctx);
  }
  async run() {
    this.runner = new ZoteroRunner({
      binary: {
        path: this.zoteroBinPath,
        devtools: this.ctx.server.devtools,
        args: this.ctx.server.startArgs
      },
      profile: {
        path: this.profilePath,
        dataDir: this.dataDir,
        // keepChanges: this.ctx.server.keepProfileChanges,
        createIfMissing: this.ctx.server.createProfileIfMissing
      },
      plugins: {
        list: [{
          id: this.ctx.id,
          sourceDir: join$1(this.ctx.dist, "addon")
        }],
        asProxy: this.ctx.server.asProxy
      }
    });
    await this.ctx.hooks.callHook("serve:init", this.ctx);
    if (this.ctx.server.prebuild) {
      await this.builder.run();
      await this.ctx.hooks.callHook("serve:prebuild", this.ctx);
    }
    await this.runner.run();
    this.runner.zotero?.on("exit", this.onZoteroExit);
    this.runner.zotero?.on("close", this.onZoteroExit);
    await this.watch();
  }
  /**
   * watch source dir and build when file changed
   */
  async watch() {
    const { source, watchIgnore } = this.ctx;
    watch(
      source,
      watchIgnore,
      {
        onReady: async () => {
          await this.ctx.hooks.callHook("serve:ready", this.ctx);
        },
        onChange: async (path) => {
          await this.ctx.hooks.callHook("serve:onChanged", this.ctx, path);
          if (path.endsWith(".ts") || path.endsWith(".tsx")) {
            await this.builder.bundle();
          } else {
            await this.builder.run();
          }
          await this.reload();
        }
      }
    );
  }
  async reload() {
    this.logger.tip("Reloading...");
    await this.runner?.reloadAllPlugins();
    await this.ctx.hooks.callHook("serve:onReloaded", this.ctx);
  }
  // Use arrow functions to keep `this`
  exit = () => {
    this.logger.info("Server shutdown by user request.");
    this.runner?.exit();
    this.ctx.hooks.callHook("serve:exit", this.ctx);
    process$1.exit();
  };
  onZoteroExit = (_code, _signal) => {
    this.logger.info(`Zotero terminated.`);
    process$1.exit();
  };
  get zoteroBinPath() {
    if (this._zoteroBinPath)
      return this._zoteroBinPath;
    this._zoteroBinPath = process$1.env.ZOTERO_PLUGIN_ZOTERO_BIN_PATH;
    if (!this._zoteroBinPath || !existsSync(this._zoteroBinPath))
      throw new Error("The Zotero binary not found.");
    return this._zoteroBinPath;
  }
  get profilePath() {
    return process$1.env.ZOTERO_PLUGIN_PROFILE_PATH;
  }
  get dataDir() {
    return process$1.env.ZOTERO_PLUGIN_DATA_DIR;
  }
}

const BASE_DIR = ".scaffold";
const CACHE_DIR = `${BASE_DIR}/cache`;
const TESTER_BASE_PATH = `${BASE_DIR}/test`;
const TESTER_PROFILE_DIR = `${TESTER_BASE_PATH}/profile`;
const TESTER_DATA_DIR = `${TESTER_BASE_PATH}/data`;
const TESTER_PLUGIN_DIR = `${TESTER_BASE_PATH}/resource`;
const TESTER_PLUGIN_REF = "zotero-plugin-scaffold-test-runner";
const TESTER_PLUGIN_ID = "scaffold-test@northword.cn";

async function prepareHeadless() {
  await installXvfb();
  await installDepsForUbuntu24();
  await installZoteroLinux();
  const xvfb = new Xvfb({
    timeout: 2e3
  });
  await xvfb.start();
}
function isPackageInstalled(packageName) {
  try {
    execSync(`dpkg-query -W ${packageName}`, { stdio: "ignore" });
    return true;
  } catch {
    return false;
  }
}
function installPackage(packageName) {
  const debug = isDebug || logger.level <= LOG_LEVEL.DEBUG;
  try {
    logger.debug(`Installing ${packageName}...`);
    execSync(`sudo apt update && sudo apt install -y ${packageName}`, { stdio: debug ? "inherit" : "pipe" });
    logger.debug(`${packageName} installed successfully.`);
  } catch (error) {
    logger.fail(`Failed to install ${packageName}. ${error}`);
    throw error;
  }
}
function checkAndInstallDependencies(packages) {
  packages.forEach((pkg) => {
    if (isPackageInstalled(pkg)) {
      logger.debug(`${pkg} is already installed.`);
    } else {
      installPackage(pkg);
    }
  });
}
async function installXvfb() {
  if (!isLinux) {
    logger.error("Unsupported platform. Please install Xvfb manually.");
    return;
  }
  const osId = execSync("cat /etc/os-release | grep '^ID='").toString();
  if (!(osId.includes("ubuntu") || osId.includes("debian"))) {
    logger.error("Unsupported Linux distribution.");
    return;
  }
  checkAndInstallDependencies(["xvfb", "x11-xkb-utils", "xkb-data"]);
}
async function installDepsForUbuntu24() {
  const version = execSync("cat /etc/os-release | grep '^VERSION_ID='").toString();
  if (!version.includes("24")) {
    logger.error("Skip to install deps due to version not 24.04.");
    return;
  }
  checkAndInstallDependencies(["libasound2t64", "libdbus-glib-1-2"]);
}
async function installZoteroLinux() {
  if (process$1.env.ZOTERO_PLUGIN_ZOTERO_BIN_PATH) {
    logger.debug("Local Zotero found, skip to download.");
    return;
  }
  logger.debug("Installing Zotero...");
  execSync(`cd ${CACHE_DIR}`);
  execSync("wget -O zotero.tar.bz2 'https://www.zotero.org/download/client/dl?platform=linux-x86_64&channel=beta'", { stdio: "pipe" });
  execSync("tar -xvf zotero.tar.bz2", { stdio: "pipe" });
  process$1.env.ZOTERO_PLUGIN_ZOTERO_BIN_PATH = `${process$1.cwd()}/Zotero_linux-x86_64/zotero`;
  execSync("cd -");
}

class TestHttpReporter {
  _server;
  _port;
  passed = 0;
  failed = 0;
  constructor() {
  }
  async getPort() {
    this._port = await findFreeTcpPort();
  }
  get port() {
    return this._port;
  }
  async start() {
    if (!this._port)
      await this.getPort();
    this._server = http.createServer(this.handleRequest.bind(this));
    this._server.listen(this._port, () => {
      logger.debug(`Server is listening on http://localhost:${this.port}`);
    });
    return this;
  }
  handleRequest(req, res) {
    if (req.method === "GET" && req.url === "/") {
      res.writeHead(200, { "Content-Type": "text/plain" });
      res.end("Zotero Plugin Test Server is running");
    } else if (req.method === "POST" && req.url === "/update") {
      let body = "";
      req.on("data", (chunk) => {
        body += chunk;
      });
      req.on("end", async () => {
        try {
          const jsonData = JSON.parse(body);
          await this.onData(jsonData);
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ message: "Results received successfully" }));
        } catch (error) {
          logger.error(`Error parsing JSON:, ${error}`);
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Invalid JSON" }));
        }
      });
    } else {
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Not Found" }));
    }
  }
  async onData(body) {
    const { type, data } = body;
    const logger_option = { space: data.indents - 1 };
    switch (type) {
      case "debug":
        logger.log(data);
        break;
      case "start":
        logger.newLine();
        break;
      case "suite":
        if (data.title)
          logger.tip(data.title, logger_option);
        break;
      case "pass":
        logger.success(`${data.title} ${styleText.gray(`${data.duration}ms`)}`, logger_option);
        break;
      case "fail": {
        let formatOutput = function(obj, indent) {
          const jsonStr = JSON.stringify(obj, null, 2);
          const lines = jsonStr.split("\n");
          const firstLine = lines[0];
          const restLines = lines.slice(1).map((line) => "  ".repeat(indent) + line).join("\n");
          return `${firstLine}
${restLines}`;
        };
        logger.fail(styleText.red(`${data.title}, ${data?.error?.message}`), logger_option);
        let expected = data.error.expected;
        let received = data.error.actual;
        if (expected && typeof expected === "object")
          expected = formatOutput(expected, data.indents + 1);
        if (received && typeof received === "object")
          received = formatOutput(received, data.indents + 1);
        logger.log(`Expected: ${styleText.green(String(expected))}`, { space: data.indents + 0.5 });
        logger.log(`Received: ${styleText.red(String(received))}`, { space: data.indents + 0.5 });
        break;
      }
      case "pending":
        logger.info(`${data.title} pending`, logger_option);
        break;
      case "suite end":
        break;
      case "end":
        this.passed = data.passed;
        this.failed = data.failed;
        logger.newLine();
        if (this.failed === 0)
          logger.success(`Test run completed - ${this.passed} passed`);
        else
          logger.fail(`Test run completed - ${this.passed} passed, ${this.failed} failed`);
        break;
      default:
        logger.log(data);
        break;
    }
  }
  stop() {
    this._server?.close();
  }
}

async function saveResource(url, path) {
  const res = await fetch(url);
  await outputFile(path, await res.text());
}

function generateBootstrap(options) {
  return `//Code generated by the zotero-plugin-scaffold tester
var chromeHandle;

function install(data, reason) {}

async function startup({ id, version, resourceURI, rootURI }, reason) {
  await Zotero.initializationPromise;
  const aomStartup = Components.classes[
    "@mozilla.org/addons/addon-manager-startup;1"
  ].getService(Components.interfaces.amIAddonManagerStartup);
  const manifestURI = Services.io.newURI(rootURI + "manifest.json");
  chromeHandle = aomStartup.registerChrome(manifestURI, [
    ["content", "${TESTER_PLUGIN_REF}", rootURI + "content/"],
  ]);

  launchTests().catch((error) => {
    Zotero.debug(error);
    Zotero.HTTP.request(
      "POST",
      "http://localhost:${options.port}/update",
      {
        body: JSON.stringify({
          type: "fail",
          data: {
            title: "Internal: Plugin awaiting timeout",
            stack: "",
            str: "Plugin awaiting timeout",
          },
        }),
      }
    );
  });
}

function onMainWindowLoad({ window: win }) {}

function onMainWindowUnload({ window: win }) {}

function shutdown({ id, version, resourceURI, rootURI }, reason) {
  if (reason === APP_SHUTDOWN) {
    return;
  }

  if (chromeHandle) {
    chromeHandle.destruct();
    chromeHandle = null;
  }
}

function uninstall(data, reason) {}

async function launchTests() {
  // Delay to allow plugin to fully load before opening the test page
  await Zotero.Promise.delay(${options.startupDelay || 1e3});

  const waitForPlugin = "${options.waitForPlugin}";

  if (waitForPlugin) {
    // Wait for a plugin to be installed
    await waitUtilAsync(() => {
      try {
        return !!eval(waitForPlugin)();
      } catch (error) {
        return false;
      }
    }).catch(() => {
      throw new Error("Plugin awaiting timeout");
    });
  }

  Services.ww.openWindow(
    null,
    "chrome://${TESTER_PLUGIN_REF}/content/index.xhtml",
    "Zotero Plugin Scaffold Test Runnner",
    "chrome,centerscreen,resizable=yes",
    {}
  );
}

function waitUtilAsync(condition, interval = 100, timeout = 1e4) {
  return new Promise((resolve, reject) => {
    const start = Date.now();
    const intervalId = setInterval(() => {
      if (condition()) {
        clearInterval(intervalId);
        resolve();
      } else if (Date.now() - start > timeout) {
        clearInterval(intervalId);
        reject();
      }
    }, interval);
  });
}
`;
}

function generateHtml(setupCode, testFiles) {
  const tests = testFiles.map((f) => `<script src="${f}"><\/script>`).join("\n    ");
  return `<!-- Generated by zotero-plugin-scaffold -->
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <title>Zotero Plugin Test</title>
    <style>
        html {
            min-width: 400px;
            min-height: 600px;
        }
        body {
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="mocha"></div>

    <!-- Include Zotero Vars -->
    <script src="chrome://zotero/content/include.js"><\/script>

    <!-- Mocha and Chai Libraries -->
    <script src="mocha.js"><\/script>
    <script src="chai.js"><\/script>

    <!-- Setup Mocha -->
    <script>
      ${setupCode}
    <\/script>

    <!-- Unit tests -->
    ${tests}

    <!-- Run Mocha -->
    <script class="mocha-exec">
      mocha.run();
    <\/script>
</body>
</html>
`;
}

function generateManifest() {
  return {
    manifest_version: 2,
    name: "Zotero Plugin Scaffold Test Runner",
    version: "0.0.1",
    description: "Test suite for the Zotero plugin. This is a runtime-generated plugin only for testing purposes.",
    applications: {
      zotero: {
        id: TESTER_PLUGIN_ID,
        update_url: "https://example.com",
        // strict_min_version: "*.*.*",
        strict_max_version: "999.*.*"
      }
    }
  };
}

function generateMochaSetup(options) {
  return `// Generated by zotero-plugin-scaffold
mocha.setup({ 
  ui: "bdd",
  reporter: Reporter,
  timeout: ${options.timeout} || 10000,
  bail: ${options.abortOnFail}
});

window.expect = chai.expect;
window.assert = chai.assert;

async function send(data) {
  const req = await Zotero.HTTP.request(
    "POST",
    "http://localhost:${options.port}/update",
    {
      body: JSON.stringify(data),
    }
  );

  if (req.status !== 200) {
    dump("Error sending data to server" + req.responseText);
    return null;
  } else {
    const result = JSON.parse(req.responseText);
    return result;
  }
}

window.debug = function (data) {
  send({ type: "debug", data });
};

let indents = 0,
  passed = 0,
  failed = 0,
  aborted = false;

// Inherit the default test settings from Zotero
function Reporter(runner) {
  function indent() {
    return "  ".repeat(indents);
  }

  function dump(str) {
    // console.log(str)
    // const p = document.createElement("p")
    // p.textContent = str
    // document.querySelector("#mocha").append(p)
    document.querySelector("#mocha").innerText += str;
  }

  runner.on("start", async function () {
    console.log("start")
    await send({ type: "start", data: { indents } });
  });

  runner.on("suite", async function (suite) {
    console.log("suite", suite)
    indents++;
    const str = indent() + suite.title + "\\n";
    dump(str);
    await send({ type: "suite", data: { title: suite.title, root: suite.root, indents } });
  });

  runner.on("suite end", async function (suite) {
    console.log("suite end", suite)
    indents--;
    const str = indents === 1 ? "\\n" : "";
    dump(str);
    await send({ type: "suite end", data: { title: suite.title, root: suite.root, indents } });
  });

  runner.on("pending", async function (test) {
    console.log("pending", test)
    const str = indent() + "pending  -" + test.title + "\\n";
    dump(str);
    await send({ type: "pending", data: { title: test.title, fulltest: test.fullTitle(), duration: test.duration, indents: indents + 1 } });
  });

  runner.on("pass", async function (test) {
    console.log("pass", test)
    passed++;
    let str = indent() + Mocha.reporters.Base.symbols.ok + " " + test.title;
    if ("fast" != test.speed) {
      str += " (" + Math.round(test.duration) + " ms)";
    }
    str += "\\n";
    dump(str);
    await send({ type: "pass", data: { title: test.title, fulltest: test.fullTitle(), duration: test.duration, indents: indents + 1 } });

  });

  runner.on("fail", async function (test, error) {
    console.log("fail", test, error)

    // Make sure there's a blank line after all stack traces
    // err.stack = err.stack.replace(/\\s*$/, "\\n\\n");

    failed++;
    let indentStr = indent();
    const str =
      indentStr +
      // Dark red X for errors
      Mocha.reporters.Base.symbols.err +
      // Trigger bell if interactive
      (Zotero.automatedTest ? "" : "\\x07") +
      " " +
      test.title +
      "\\n" +
      indentStr +
      "  " +
      error.message +
      // " at\\n" +
      // err.stack.replace(/^/gm, indentStr + "    ").trim() +
      "\\n\\n";
    dump(str);

    await send({ type: "fail", data: { title: test.title, fulltest: test.fullTitle(), duration: test.duration, error, indents: indents + 1 } });

  });

  runner.on("end", async function () {
    console.log("end")
    const str =
      passed +
      "/" +
      (passed + failed) +
      " tests passed" +
      (aborted ? " -- aborting" : "") +
      "\\n";
    dump(str);

    await send({
      type: "end",
      data: { passed: passed, failed: failed, aborted: aborted, str, indents },
    });

    // Must exit on Zotero side, otherwise the exit code will not be 0 and CI will fail
    if (${options.exitOnFinish ? "true" : "false"}) {
      Zotero.Utilities.Internal.quit(0);
    }
  });
}
`;
}

class TestBundler {
  constructor(ctx, port) {
    this.ctx = ctx;
    this.port = port;
  }
  esbuildContext;
  async generate() {
    await this.generateTestResources();
    await this.createTestHtml();
  }
  async regenerate(changedFile) {
    const esbuildResult = await this.esbuildContext?.rebuild();
    const tests = findImpactedTests(changedFile, esbuildResult?.metafile);
    await this.createTestHtml(tests);
  }
  async generateTestResources() {
    const manifest = generateManifest();
    await outputJSON(`${TESTER_PLUGIN_DIR}/manifest.json`, manifest, { spaces: 2 });
    const bootstrap = generateBootstrap({
      port: this.port,
      startupDelay: this.ctx.test.startupDelay,
      waitForPlugin: this.ctx.test.waitForPlugin
    });
    await outputFile(`${TESTER_PLUGIN_DIR}/bootstrap.js`, bootstrap);
    await this.copyTestLibraries();
    await this.bundleTests();
  }
  async copyTestLibraries() {
    const pkgs = [
      {
        name: "mocha.js",
        local: "node_modules/mocha/mocha.js",
        remote: "https://cdn.jsdelivr.net/npm/mocha/mocha.js"
      },
      {
        name: "chai.js",
        // local: "node_modules/chai/chai.js",
        local: "",
        // chai packages install from npm do not support browser
        remote: "https://www.chaijs.com/chai.js"
      }
    ];
    await Promise.all(pkgs.map(async (pkg) => {
      const targetPath = `${TESTER_PLUGIN_DIR}/content/${pkg.name}`;
      if (pkg.local && await pathExists(pkg.local)) {
        logger.debug(`Local ${pkg.name} package found`);
        await copy(pkg.local, targetPath);
        return;
      }
      const cachePath = `${CACHE_DIR}/${pkg.name}`;
      if (await pathExists(`${cachePath}`)) {
        logger.debug(`Cache ${pkg.name} package found`);
        await copy(cachePath, targetPath);
        return;
      }
      logger.info(`No local ${pkg.name} found, we recommend you install ${pkg.name} package locally.`);
      await saveResource(pkg.remote, `${CACHE_DIR}/${pkg.name}`);
      await copy(cachePath, targetPath);
    }));
  }
  async bundleTests() {
    const testDirs = toArray(this.ctx.test.entries);
    const entryPoints = (await Promise.all(testDirs.map((dir) => glob(`${dir}/**/*.{spec,test}.[jt]s`)))).flat();
    this.esbuildContext = await context({
      entryPoints,
      outdir: `${TESTER_PLUGIN_DIR}/content/units`,
      bundle: true,
      target: "firefox115",
      metafile: true
    });
    await this.esbuildContext.rebuild();
  }
  async createTestHtml(tests = []) {
    const setupCode = generateMochaSetup({
      timeout: this.ctx.test.mocha.timeout,
      port: this.port,
      abortOnFail: this.ctx.test.abortOnFail,
      exitOnFinish: !this.ctx.test.watch
    });
    let testFiles = tests;
    if (testFiles.length === 0) {
      testFiles = (await glob(`**/*.{spec,test}.js`, { cwd: `${TESTER_PLUGIN_DIR}/content` })).sort();
    }
    const html = generateHtml(setupCode, testFiles);
    await outputFile(`${TESTER_PLUGIN_DIR}/content/index.xhtml`, html);
  }
}
function findImpactedTests(changedFilePath, buildMetadata) {
  if (!buildMetadata)
    return [];
  const resolvedChangedFile = resolve$1(changedFilePath);
  const impactedTestFiles = /* @__PURE__ */ new Set();
  for (const [outputFilePath, outputInfo] of Object.entries(buildMetadata.outputs)) {
    const testFilePath = outputFilePath.replace(`${TESTER_PLUGIN_DIR}/content/`, "");
    if (Object.keys(outputInfo.inputs).some((inputPath) => resolve$1(inputPath) === resolvedChangedFile)) {
      impactedTestFiles.add(testFilePath);
    }
  }
  return Array.from(impactedTestFiles);
}

class Test extends Base {
  builder;
  zotero;
  reporter = new TestHttpReporter();
  testBundler;
  constructor(ctx) {
    super(ctx);
    process$1.env.NODE_ENV ??= "test";
    this.builder = new Build(ctx);
    if (isCI) {
      this.ctx.test.headless = true;
      this.ctx.test.watch = false;
    }
  }
  async run() {
    await emptyDir(TESTER_PROFILE_DIR);
    await emptyDir(TESTER_DATA_DIR);
    await emptyDir(TESTER_PLUGIN_DIR);
    await this.ctx.hooks.callHook("test:init", this.ctx);
    await this.builder.run();
    await this.ctx.hooks.callHook("test:prebuild", this.ctx);
    await this.reporter.start();
    this.testBundler = new TestBundler(
      this.ctx,
      this.reporter.port
    );
    await this.testBundler.generate();
    await this.ctx.hooks.callHook("test:bundleTests", this.ctx);
    await this.startZotero();
    await this.ctx.hooks.callHook("test:run", this.ctx);
    if (this.ctx.test.watch) {
      this.watch();
    }
  }
  async watch() {
    const source = toArray(this.ctx.source).map((p) => resolve$1(p));
    const tests = toArray(this.ctx.test.entries).map((p) => resolve$1(p));
    function isSource(_path) {
      const path = resolve$1(_path);
      const isSource2 = source.find((s) => path.match(s)) || false;
      tests.find((t) => path.match(t)) || false;
      return isSource2;
    }
    watch(
      [this.ctx.source, this.ctx.test.entries].flat(),
      this.ctx.watchIgnore,
      {
        onChange: async (path) => {
          if (isSource(path)) {
            await this.builder.run();
            await this.testBundler?.regenerate(path);
            await this.zotero?.reloadAllPlugins();
          } else {
            await this.testBundler?.regenerate(path);
            await this.zotero?.reloadTemporaryPluginBySourceDir(TESTER_PLUGIN_DIR);
          }
        },
        onAdd: async (path) => {
          if (isSource(path)) {
            await this.builder.run();
            await this.testBundler?.regenerate(path);
            await this.zotero?.reloadAllPlugins();
          } else {
            await this.testBundler?.generate();
            await this.zotero?.reloadTemporaryPluginBySourceDir(TESTER_PLUGIN_DIR);
          }
        }
      }
    );
  }
  async startZotero() {
    if (this.ctx.test.headless) {
      await prepareHeadless();
    }
    this.zotero = new ZoteroRunner({
      binary: {
        path: this.zoteroBinPath,
        devtools: this.ctx.server.devtools,
        args: this.ctx.server.startArgs
      },
      profile: {
        path: TESTER_PROFILE_DIR,
        dataDir: TESTER_DATA_DIR,
        customPrefs: this.prefs
      },
      plugins: {
        list: [{
          id: this.ctx.id,
          sourceDir: join$1(this.ctx.dist, "addon")
        }, {
          id: TESTER_PLUGIN_ID,
          sourceDir: TESTER_PLUGIN_DIR
        }]
      }
    });
    await this.zotero.run();
    this.zotero.zotero?.on("close", () => this.onZoteroExit());
  }
  onZoteroExit = () => {
    this.reporter.stop();
    this.ctx.hooks.callHook("test:exit", this.ctx);
    if (this.reporter.failed)
      process$1.exit(1);
    else
      process$1.exit(0);
  };
  exit = (code) => {
    if (code === "SIGINT") {
      this.logger.info("Tester shutdown by user request");
    }
    this.reporter.stop();
    this.zotero?.exit();
    this.ctx.hooks.callHook("test:exit", this.ctx);
    process$1.exit();
  };
  get zoteroBinPath() {
    if (!process$1.env.ZOTERO_PLUGIN_ZOTERO_BIN_PATH)
      throw new Error("No Zotero Found.");
    return process$1.env.ZOTERO_PLUGIN_ZOTERO_BIN_PATH;
  }
  get prefs() {
    const defaultPref = {
      "extensions.experiments.enabled": true,
      "extensions.autoDisableScopes": 0,
      // Enable remote-debugging
      "devtools.debugger.remote-enabled": true,
      "devtools.debugger.remote-websocket": true,
      "devtools.debugger.prompt-connection": false,
      // Inherit the default test settings from Zotero
      "app.update.enabled": false,
      "extensions.zotero.sync.server.compressData": false,
      "extensions.zotero.automaticScraperUpdates": false,
      "extensions.zotero.debug.log": 5,
      "extensions.zotero.debug.level": 5,
      "extensions.zotero.debug.time": 5,
      "extensions.zotero.firstRun.skipFirefoxProfileAccessCheck": true,
      "extensions.zotero.firstRunGuidance": false,
      "extensions.zotero.firstRun2": false,
      "extensions.zotero.reportTranslationFailure": false,
      "extensions.zotero.httpServer.enabled": true,
      "extensions.zotero.httpServer.port": 23124,
      "extensions.zotero.httpServer.localAPI.enabled": true,
      "extensions.zotero.backup.numBackups": 0,
      "extensions.zotero.sync.autoSync": false,
      "extensions.zoteroMacWordIntegration.installed": true,
      "extensions.zoteroMacWordIntegration.skipInstallation": true,
      "extensions.zoteroWinWordIntegration.skipInstallation": true,
      "extensions.zoteroOpenOfficeIntegration.skipInstallation": true
    };
    return Object.assign(defaultPref, this.ctx.test.prefs || {});
  }
}

const Config = {
  defineConfig,
  loadConfig
};

export { Build as B, Config as C, ExitSignals as E, Release as R, Serve as S, Test as T, defineConfig as d };

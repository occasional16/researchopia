# 1.4.6 共享标注原生化展示方案

**创建日期**: 2025-11-19  
**相关任务**: annotation-popup 功能增强  
**优先级**: P1  
**状态**: 🤔 待评估

---

## 背景

**当前状态**:
- ✅ 自己的标注: 在 PDF 展示为原生高亮/下划线
- ✅ 点击 → 弹出原生 annotation-popup (包含 comment + 4个共享按钮)
- ❌ 他人共享标注: 仅在侧边栏卡片展示,PDF中不可见
- ❌ 点击侧边栏卡片 → 只弹出 `researchopia-annotation-popup`,不是原生样式

**需求**:
- 其他人的共享标注以**原生标注形式**展示在 PDF 页面
- 点击后弹出**类似原生 annotation-popup** 的弹窗 (无共享按钮、展示comment但不可编辑)

---

## 核心问题

### Q1: Zotero如何展示原生标注?

**关键发现** (从GitHub zotero/zotero源码):

1. **标注存储**: `Zotero.Annotations` (chrome/content/zotero/xpcom/annotations.js)
   - 类型常量: `ANNOTATION_TYPE_HIGHLIGHT`, `ANNOTATION_TYPE_UNDERLINE`, etc.
   - 必须字段: `position` (pageIndex + rects坐标数组), `type`, `color`, `sortIndex`

2. **渲染流程** (chrome/content/zotero/xpcom/reader.js):
   ```javascript
   // ReaderInstance._getAnnotation() Line 1392
   async _getAnnotation(item) {
     if (!item.isAnnotation()) return null;
     let json = await Zotero.Annotations.toJSON(item);
     json.id = item.key;
     return json;  // 传递给 PDF.js renderer
   }
   ```

3. **PDF.js集成**:
   - Zotero使用修改版PDF.js作为渲染引擎
   - 标注通过 `_internalReader._annotationManager.addAnnotation()` 添加到PDF
   - 必须提供 `position.rects` 坐标 (左下角坐标系)

**结论**: 原生标注 = **Zotero.Item (annotationType='highlight')** → **通过PDF.js渲染到canvas/SVG**

---

### Q2: 如何让共享标注变成"原生标注"?

**两种技术路径**:

#### 方案A: 创建"虚拟 Zotero.Item" ⚠️

**原理**: 为每个共享标注在Zotero中创建item

**步骤**:
1. 查询 Supabase `shared_annotations` 表获取他人标注
2. 对每个标注调用 `Zotero.Annotations.saveFromJSON()`:
   ```javascript
   await Zotero.Annotations.saveFromJSON(attachment, {
     key: 'GENERATED_KEY', // 生成唯一key
     type: 'highlight',
     text: annotation.content,
     comment: annotation.comment,
     color: annotation.color || '#ffd400',
     position: JSON.parse(annotation.position),
     pageLabel: annotation.page_number,
     sortIndex: annotation.sort_index || '00000|000000|00000',
     readOnly: true,  // 🔑 关键: 标记为只读
     isExternal: true // 🔑 标记为外部标注
   });
   ```
3. Zotero自动渲染到PDF

**优点**:
- ✅ 完全原生体验 (高亮效果、位置准确)
- ✅ 复用Zotero所有annotation UI逻辑
- ✅ 自动处理分页、缩放、滚动

**缺点**:
- ❌ **数据污染**: 他人标注混入本地数据库
- ❌ **同步冲突**: 可能被误同步到Zotero服务器
- ❌ **删除问题**: 关闭PDF后需清理虚拟item
- ❌ **权限混乱**: 需hack `readOnly`和`isExternal`标志

---

#### 方案B: 直接调用PDF.js API ⭐ (推荐)

**原理**: 绕过Zotero.Item,直接向PDF.js注入标注

**步骤**:
1. 获取 `reader._internalReader._annotationManager`
2. 调用 `addAnnotation()`:
   ```javascript
   reader._internalReader._annotationManager.addAnnotation(
     Components.utils.cloneInto({
       id: 'shared_' + annotation.id,  // 使用Supabase ID
       type: 'highlight',
       color: annotation.color || '#ffd400',
       position: {
         pageIndex: annotation.page_number - 1,  // 0-based
         rects: JSON.parse(annotation.position).rects
       },
       text: annotation.content,
       comment: annotation.comment,
       readOnly: true,  // 🔑 禁止编辑
       authorName: annotation.username || '匿名用户'
     }, reader._iframeWindow)
   );
   ```
3. 监听annotation点击事件:
   ```javascript
   Zotero.Reader.registerEventListener('annotationClick', (event) => {
     if (event.id.startsWith('shared_')) {
       // 弹出自定义popup (不是原生annotation-popup)
       showSharedAnnotationPopup(event.annotation, event.position);
     }
   });
   ```

**优点**:
- ✅ **数据隔离**: 不污染Zotero数据库
- ✅ **灵活控制**: 可自定义只读行为、点击响应
- ✅ **易于清理**: 切换PDF时重新加载即可

**缺点**:
- ⚠️ **API不稳定**: PDF.js内部API可能随版本变化
- ⚠️ **需要hack**: `readOnly`字段可能不生效 (需测试)
- ⚠️ **自定义popup**: 无法复用原生annotation-popup (需重新实现)

---

### Q3: 如何弹出"类原生 annotation-popup"?

**原生popup限制**:
- 只能通过 Zotero.Items 触发
- 无法传入自定义数据

**解决方案**: 创建**高仿原生popup**

**实现** (复用 `PDFReaderCoordinator.ts` Line 486-650 的逻辑):

```typescript
// 在 PDFReaderCoordinator.ts 或新文件中
export class SharedAnnotationPopup {
  static show(annotation: any, position: { x: number, y: number }, readerDoc: Document) {
    // 1. 创建popup容器 (样式与原生.annotation-popup一致)
    const popup = readerDoc.createElement('div');
    popup.className = 'researchopia-shared-annotation-popup';
    popup.style.cssText = `
      position: absolute;
      left: ${position.x}px;
      top: ${position.y}px;
      min-width: 300px;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      padding: 12px;
      z-index: 10000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 12px;
    `;
    
    // 2. 添加"只读"标识
    const readOnlyBadge = readerDoc.createElement('div');
    readOnlyBadge.textContent = '🔒 只读 (他人标注)';
    readOnlyBadge.style.cssText = `
      background: #f0f0f0;
      color: #666;
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 3px;
      margin-bottom: 8px;
    `;
    popup.appendChild(readOnlyBadge);
    
    // 3. 作者信息
    const author = annotation.username || '匿名用户';
    const authorDiv = readerDoc.createElement('div');
    authorDiv.textContent = author;
    authorDiv.style.cssText = `
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid #e0e0e0;
    `;
    popup.appendChild(authorDiv);
    
    // 4. 标注内容 (原文高亮)
    if (annotation.content) {
      const contentDiv = readerDoc.createElement('div');
      contentDiv.textContent = annotation.content;
      contentDiv.style.cssText = `
        font-size: 12px;
        color: #444;
        padding: 8px;
        background: #f5f5f5;
        border-radius: 3px;
        margin-bottom: 8px;
      `;
      popup.appendChild(contentDiv);
    }
    
    // 5. Comment (如果有)
    if (annotation.comment) {
      const commentDiv = readerDoc.createElement('div');
      commentDiv.textContent = annotation.comment;
      commentDiv.style.cssText = `
        color: #333;
        padding: 8px;
        background: #fffbea;
        border-radius: 3px;
        margin-bottom: 8px;
      `;
      popup.appendChild(commentDiv);
    }
    
    // 6. 点赞和评论 (异步加载)
    this.loadSocialInfo(annotation.id, popup, readerDoc);
    
    // 7. 添加到页面
    const pageContainer = readerDoc.querySelector('.page'); // PDF.js page容器
    pageContainer?.appendChild(popup);
    
    // 8. 点击外部关闭
    const closeHandler = (e: MouseEvent) => {
      if (!popup.contains(e.target as Node)) {
        popup.remove();
        readerDoc.removeEventListener('click', closeHandler);
      }
    };
    setTimeout(() => readerDoc.addEventListener('click', closeHandler), 100);
  }
  
  static async loadSocialInfo(annotationId: string, popup: HTMLElement, doc: Document) {
    // 与 1.4.5 方案中的 loadSharedInfo() 逻辑相同
    // 查询点赞、评论并渲染
  }
}
```

**样式差异**:
- 原生popup: `.annotation-popup` (Zotero内置样式)
- 我们的popup: `.researchopia-shared-annotation-popup` (自定义,但高仿)

---

## 技术实现详解

### 阶段1: 加载共享标注 (初始化)

**时机**: 打开PDF时 (`PDFReaderCoordinator.init()`)

**流程**:
1. 获取当前PDF的DOI:
   ```typescript
   const attachment = Zotero.Items.get(reader.itemID);
   const paperItem = attachment.parentItem;
   const doi = paperItem?.getField('DOI');
   ```

2. 查询Supabase获取该论文的共享标注:
   ```typescript
   const { data: sharedAnnotations } = await supabaseManager.client
     .from('annotations')
     .select(`
       *,
       users (username, avatar_url)
     `)
     .eq('document.doi', doi)
     .in('visibility', ['public', 'shared'])
     .neq('user_id', currentUserId); // 排除自己的标注
   ```

3. 注入到PDF.js:
   ```typescript
   for (const annotation of sharedAnnotations) {
     await reader._internalReader._annotationManager.addAnnotation(
       Components.utils.cloneInto({
         id: `shared_${annotation.id}`,
         type: annotation.type,
         color: annotation.color || '#ffd400',
         position: JSON.parse(annotation.position),
         text: annotation.content,
         comment: annotation.comment,
         readOnly: true,
         authorName: annotation.users?.username || '匿名用户'
       }, reader._iframeWindow)
     );
   }
   ```

---

### 阶段2: 监听点击事件 (交互)

**Zotero Reader事件系统** (chrome/content/zotero/xpcom/reader.js Line 2011-2068):

```typescript
// 注册事件监听器 (在 annotationSharingPopup.ts 的 init() 中)
Zotero.Reader.registerEventListener('createAnnotationContextMenu', (event) => {
  const { reader, params } = event;
  
  // 判断是否为共享标注
  if (params.ids[0]?.startsWith('shared_')) {
    // 添加上下文菜单选项
    event.append({
      label: '查看标注详情',
      onCommand: () => {
        const annotationId = params.ids[0].replace('shared_', '');
        showSharedAnnotationDetail(annotationId, reader);
      }
    });
  }
});
```

**但是** - Zotero **没有** `annotationClick` 事件!

**替代方案**: 监听PDF.js的DOM事件

```typescript
// 在 reader._iframeWindow 中监听点击
const readerDoc = reader._iframeWindow.document;

readerDoc.addEventListener('click', (e: MouseEvent) => {
  const target = e.target as HTMLElement;
  
  // PDF.js annotation元素的特征
  if (target.matches('.annotationLayer section[data-annotation-id]')) {
    const annotationId = target.dataset.annotationId;
    
    if (annotationId?.startsWith('shared_')) {
      e.preventDefault();
      e.stopPropagation();
      
      // 获取点击位置
      const rect = target.getBoundingClientRect();
      const position = { x: rect.left, y: rect.bottom + 5 };
      
      // 弹出自定义popup
      SharedAnnotationPopup.show(annotationId, position, readerDoc);
    }
  }
});
```

---

### 阶段3: 处理边缘情况

#### 3.1 性能优化

**问题**: 加载大量共享标注会拖慢PDF打开速度

**解决**:
- 分页加载: 只加载当前页 + 前后各2页的标注
- 惰性渲染: 用户滚动时动态加载其他页
- 缓存: 存储已查询的标注列表,切换页面时复用

#### 3.2 冲突检测

**问题**: 自己的标注和他人的共享标注位置重叠

**解决**:
- 颜色区分: 他人标注使用不同色调 (例如降低饱和度)
- 堆叠显示: CSS `z-index` 让自己的标注优先显示
- 视觉提示: 他人标注增加虚线边框

#### 3.3 实时同步

**问题**: 他人新增标注后,当前打开的PDF不更新

**解决**:
- WebSocket: 监听 Supabase Realtime 通道
- 增量更新: 新标注到达时调用 `addAnnotation()` 追加
- 通知提示: "检测到新标注,点击刷新"

#### 3.4 权限控制

**问题**: 私密标注泄露、匿名标注显示作者

**解决**:
- 查询时过滤: `WHERE visibility IN ('public', 'shared')`
- 匿名处理: `show_author_name=false` → `authorName: '匿名用户'`
- RLS策略: 在Supabase层面限制访问权限

---

## 关键代码位置

### 现有代码

| 文件 | 行数 | 功能 | 复用方式 |
|------|------|------|----------|
| `PDFReaderCoordinator.ts` | 486-650 | 共享标注弹窗渲染 | 提取 `SharedAnnotationPopup.show()` |
| `PDFReaderCoordinator.ts` | 343-437 | 点击侧边栏卡片展示标注 | 复用定位逻辑 (page/rect查找) |
| `annotationSharingPopup.ts` | 590-750 | Annotation-popup注入 | 参考polling机制 |
| `supabase.ts` | 245 | 查询共享标注 | 复用 `getAnnotationsForDocument()` |

### 新增文件

**建议结构**:
```
zotero-plugin/src/modules/pdf/
├── PDFReaderCoordinator.ts (已存在)
├── SharedAnnotationManager.ts (🆕 管理共享标注加载)
├── SharedAnnotationPopup.ts (🆕 弹窗展示)
└── SharedAnnotationRenderer.ts (🆕 PDF.js渲染集成)
```

---

## 实现计划

### Phase 1: 基础渲染 (2-3天)
- [ ] 创建 `SharedAnnotationManager.ts`
- [ ] 实现 `loadSharedAnnotations()` 查询逻辑
- [ ] 调用 PDF.js `addAnnotation()` 注入高亮
- [ ] 测试只读标注是否可编辑 (验证 `readOnly` 标志)

### Phase 2: 交互响应 (1-2天)
- [ ] 创建 `SharedAnnotationPopup.ts`
- [ ] 实现点击检测 (DOM事件监听)
- [ ] 渲染高仿原生popup (包含作者、内容、comment)
- [ ] 集成点赞/评论数据

### Phase 3: 性能优化 (1天)
- [ ] 实现分页加载 (只加载可见页标注)
- [ ] 添加缓存机制 (避免重复查询)
- [ ] 优化渲染性能 (批量注入标注)

### Phase 4: 实时同步 (2天)
- [ ] 集成 Supabase Realtime
- [ ] 监听 `annotations` 表变化
- [ ] 实现增量更新 (新标注动态添加)
- [ ] 处理删除/更新事件

### Phase 5: 边缘情况处理 (1天)
- [ ] 处理位置重叠 (颜色区分)
- [ ] 处理权限控制 (匿名/私密)
- [ ] 处理错误情况 (坐标不合法、PDF损坏)
- [ ] 添加降级处理 (PDF.js API失效时回退到侧边栏)

**总计**: ~7-9天

---

## 风险评估

### 技术风险

1. **PDF.js API变更** (⚠️ 高)
   - Zotero使用fork版PDF.js,内部API可能变化
   - 解决: 添加版本检测,不兼容时禁用功能

2. **readOnly标志不生效** (⚠️ 中)
   - PDF.js可能不支持 `readOnly` 字段
   - 解决: 监听编辑事件,手动阻止修改 + toast提示

3. **性能问题** (⚠️ 中)
   - 大量标注 (>100个) 可能导致卡顿
   - 解决: 分页加载 + 虚拟化渲染

### 用户体验风险

1. **视觉混乱** (⚠️ 中)
   - 自己标注 + 他人标注 + PDF内嵌标注混合
   - 解决: 颜色区分 + 增加"只显示我的标注"开关

2. **误操作** (⚠️ 低)
   - 用户以为他人标注是自己的,尝试编辑
   - 解决: "只读"标识 + 鼠标悬停提示

---

## 未决问题

1. **是否需要完全原生popup?**
   - 选项A: 高仿popup (灵活,但需维护样式)
   - 选项B: 尝试hack原生popup (复用Zotero逻辑,但可能不兼容)

2. **如何处理PDF内嵌标注?**
   - 场景: PDF本身包含其他软件生成的标注
   - 选项A: 忽略 (只显示Researchopia标注)
   - 选项B: 导入并转换为Zotero标注

3. **是否支持离线查看?**
   - 问题: 共享标注存储在Supabase,离线无法访问
   - 选项A: 不支持 (提示"需联网")
   - 选项B: 本地缓存上次加载的标注

---

## 参考资料

- **Zotero Reader源码**: `chrome/content/zotero/xpcom/reader.js` Line 1392-2068
- **PDF.js Annotation API**: `reader._internalReader._annotationManager`
- **现有共享标注popup**: `zotero-plugin/src/modules/pdf/PDFReaderCoordinator.ts` Line 486-650
- **Annotation数据结构**: `test/tests/annotationsTest.js` Line 0-127 (示例JSON)
- **PDF.js文档**: https://mozilla.github.io/pdf.js/api/

---

**结论**: 
- **推荐方案**: 方案B (直接调用PDF.js API) + 自定义高仿popup
- **关键挑战**: PDF.js内部API稳定性、readOnly标志支持
- **预计工期**: 7-9天 (含测试和优化)
- **用户价值**: 显著提升共享标注可见性,提高协作效率
